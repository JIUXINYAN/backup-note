---
title: 核心编程
date: 2019-01-09 14:08:30
categories: 
          - php
tags:
    - php
notshow: true
---
# 核心编程

<!-- more -->


# 1. 表单传值

## 1.1  概念

### 1.1.1 why使用

绝大部分的网站几乎都拥有登陆或注册页面，并且也都拥有录入信息的后台。

比如我们在网站的登陆页面或注册页面填写信息提交后，填写的信息之所以能够传递到服务器，就是因为网站的页面中使用了==表单传值==；



### 1.2 what

概念：表单传值指的是通过==表单==构建数据，传递给服务器。 



## 1.2 表单传值的方式

表单传值的方式包含两种：

- [x] POST方式
- [x] GET方式



### 1.2.1POST方式

**==需求==**：使用POST方式实现一个会员注册页面，包含帐号，密码两个填写项。

**==解答==**：构建一个名为code1.html的页面，代码如下

![5](\images\two\img_d11\5.png)



### 1.2.2 GET方式

==**需求**==：使用GET方式实现一个会员注册页面，包含帐号，密码两个填写项。

**==解答==**：构建一个名为code2.html的页面，代码如下

![6](\images\two\img_d11\6.png)

**==小结==**

表单传值的方式包括两种：1）GET方式；2）POST方式；

表单传值的方式指的是：将数据传递给服务器的方式；



==**提问**==：有传递就则必定有接收，通过表单传递方式传递出去的数据，在服务器端的PHP程序页面需要如何接收呢？



## 1.3  接收数据的方式

PHP接收数据的方式包含三种：

- [x] $_POST方式
- [x] $_GET方式
- [x] $_REQUEST方式



### 1.3.1 $\_POST方式

$_POST作用：只接收POST方式传递的数据。



**==需求==**：使用POST方式实现一个会员注册表单页面，包含帐号，密码两个填写项，同时实现在程序页面中使用$\_POST和$\_GET接收并输出表单页面提交传递的数据。

**==解答==**：

第一步，构建一个名为code3.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
	<meta charset="UTF-8">
	<title>注册页面</title>
</head>
<body>
	<form method="post" action="http://www.home.com/class/day11/code/code4.php" >
		<p>
			<span>帐号：</span>
			<input type="text" name="acc"/>
		</p>
		<p>
			<span>密码：</span>
			<input type="password" name="pwd"/>
		</p>
		<p>
			<input type="submit" value="立即注册" />
		</p>
	</form>
</body>
</HTML>
```

第二步，构建名为code4.php的程序处理页面，代码如下

```php
<?php

echo '$_POST：'; 
print_r($_POST);  echo '<br/>';

echo '$_GET：'; 
print_r($_GET);
```

第三步，访问code3.html页面，填写注册数据，![7](\images\two\img_d11\7.png)

第四步，点击提交按钮，查看最终提交后的效果，

![8](\images\two\img_d11\8.png)

**==小结==**：

1. $_GET只能接受get方式传递的数据，而不能接受post方式传递的数据；



### 1.3.2 $_GET方式

作用：只接收GET方式传递的数据。



**==需求==**：使用GET方式实现一个会员注册表单页面，包含帐号，密码两个填写项，同时实现在程序页面中使用$\_GET和$\_POST接收并输出表单页面提交传递的数据。

**==解答==**：

第一步，构建一个名为code5.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
	<meta charset="UTF-8">
	<title>注册页面</title>
</head>
<body>
	<form method="get" action="http://www.home.com/class/day11/code/code6.php" >
		<p>
			<span>帐号：</span>
			<input type="text" name="acc"/>
		</p>
		<p>
			<span>密码：</span>
			<input type="password" name="pwd"/>
		</p>
		<p>
			<input type="submit" value="立即注册" />
		</p>
	</form>
</body>
</HTML>
```

第二步，构建名为code6.php的程序处理页面，代码如下

```php
<?php

echo '$_POST：'; 
print_r($_POST);  echo '<br/>';

echo '$_GET：'; 
print_r($_GET);
```

第三步，访问code5.html页面，填写注册数据，

![9](\images\two\img_d11\9.png)

第四步，点击提交按钮，查看最终提交后的效果，

![10](\images\two\img_d11\10.png)

**==小结==**：

1. $_POST只能接受post方式传递的数据，而不能接受get方式传递的数据；



#### 1）表单传值GET方式的核心特征

使用GET方式传递数据时，提交后的链接地址的格式比较特殊，这个固定格式的链接地址就是GET方式提交数据的核心特征。



GET方式核心特征格式说明：

![11](\images\two\img_d11\11.png)

### 1.3.3 $_REQUEST方式

作用：同时包含$\_POST，$\_GET和$\_COOKIE的数据。



**==需求==**：

1. 在一个form表单中同时使用POST方式和GET方式实现表单传值，其中POST方式传递帐号和密码两个需要填写的数据，GET方式固定传递国籍country=china数据；
2. 实现在程序页面中使用$\_GET、$\_POST和$\_REQUEST接收并输出表单页面提交传递的数据。

**==解答==**：

第一步，构建一个名为code7.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
	<meta charset="UTF-8">
	<title>注册页面</title>
</head>
<body>
	<form method="post" action="http://www.home.com/class/day11/code/code8.php?country=china" >
		<p>
			<span>帐号：</span>
			<input type="text" name="acc"/>
		</p>
		<p>
			<span>密码：</span>
			<input type="password" name="pwd"/>
		</p>
		<p>
			<input type="submit" value="立即注册" />
		</p>
	</form>
</body>
</HTML>
```

第二步，构建名为code8.php的程序处理页面，代码如下

```php
<?php

echo '$_POST：'; 
print_r($_POST);  echo '<br/>';

echo '$_GET：'; 
print_r($_GET); echo '<br/>';

echo '$_REQUEST'; 
print_r($_REQUEST);
```

第三步，访问code7.html页面，填写注册数据，

![12](\images\two\img_d11\12.png)

第四步，点击提交按钮，查看最终提交后的效果，

![13](\images\two\img_d11\13.png)

**==小结==**：$_QUERST就是包含$\_GET和$\_POST两部分数据的数组集合。





==**提问**==：$\_REQUEST即包含$_POST元素数据，又包含$\_GET元素数据，那么当$\_POST与$\_GET存在下标同名的元素时，$\_REQUET将会选择谁的数据作为最终值？

构建code9.html程序文件，代码如下：

![14](\images\two\img_d11\14.png)

构建code10.php程序文件代码如下：

![15](\images\two\img_d11\15.png)

测试访问code9.html，并且构建填写的注册数据，

![16](\images\two\img_d11\16.png)

点击注册按钮后，效果为：

![17](\images\two\img_d11\17.png)

虽然从直观的效果上，我们观察到$_REQUEST包含的是$\_POST的数据，但是最终$\_REQUEST采用谁的数据，实际上是取决于php.ini中的名为request\_order配置项的具体配置而言的。

![18](\images\two\img_d11\18.png)



### 1.3.4 POST与GET区别

无论是POST方式，还是GET方式，都属于表单传值。而表单传值的最终目的就是==构建数据传输给服务器==，这也就意味着POST方式和GET方式都能用来传输数据给服务器。

那么既然存在两种方式，我们在实际应用中应该如何来选择使用呢？

为此，我们需要进一步学习POST方式与GET方式之间的区别。POST方式与GET方式主要区别有四点：



- GET方式具有可见性，而POST方式不具有可见性；
- 基于第一点，POST方式在安全性上比GET方式要高一些；
- 在传输的数据量上，POST方式可能比GET方式要大；
- 在支持的数据类型上，GET方式仅支持ASCII码数据类型，POST方式无限制；



以上四点主要区别，无一例外，都说明了理论上POST方式比GET方式好，而在实际的使用中，我们在构建form表单时，method通常都是被指定为post方式。



==**提问**==：既然POST方式比GET方式优越，为什么还会有GET方式呢？

### 1.3.5 GET应用

#### 1) 指定a标签的href属性

**==需求==**：构建分类列表页，实现点击每个分类都将跳转到同一个页面，但是最终将会输出与点击的分类相关的产品信息。

**==解答==**：

第一步，构建一个名为code11.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
	<meta charset="UTF-8">
	<title>产品分类页面</title>
</head>
<body>
	<a href="http://www.home.com/class/day11/code/code12.php?type=1">一脚蹬</a>
	<a href="http://www.home.com/class/day11/code/code12.php?type=2">帆布鞋</a>
	<a href="http://www.home.com/class/day11/code/code12.php?type=3">拖孩</a>
</body>
</HTML>
```

第二步，构建名为code12.php的程序处理页面，代码如下

```php
<?php

//var_dump( $_GET['type'] ); 

if( $_GET['type']==1 ){//表示要展示一脚蹬鞋

    echo '<span>一脚蹬1</span><br/>'; 
    echo '<span>一脚蹬2</span><br/>'; 
    echo '<span>一脚蹬3</span>'; 

}elseif( $_GET['type']==2 ){//表示要展示帆布鞋

    echo '<span>帆布鞋1</span><br/>'; 
    echo '<span>帆布鞋2</span><br/>'; 
    echo '<span>帆布鞋3</span>'; 

}elseif( $_GET['type']==3 ){//表示要展示拖孩

    echo '<span>拖孩1</span><br/>'; 
    echo '<span>拖孩2</span><br/>'; 
    echo '<span>拖孩3</span>'; 
}
```

第三步，访问code11.html，点击不同的分类，查看最终效果

![img](\images\two\img_d11/19.png?lastModify=1535118571)

点击后效果为：

![img](\images\two\img_d11/20.png?lastModify=1535118571)

#### 2)  js中指定location对象的href属性

**==需求==**：

1. 构建商品购买页面，假设商品库存为100个，要求有填写购买数量的输入框和立即购买按钮；
2. 在商品购买页面中需要实现当点击立即购买按钮时，会根据用户填写的商品购买数量进行判断，如果没有超出库存则允许购买，如果超出库存则给出提示且不允许购买；

**==解答==**：

第一步，构建一个名为code13.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>拖孩1</title>
</head>
<body>
    <input type="text" id="buyNum" />库存数量为：100个 <br/><br/>
    <button id="btn">立即购买</button>
<script type="text/javascript">

var totalNum = 100;//定义变量保存库存数量

document.getElementById('btn').onclick = function (){

    var buyNum = document.getElementById('buyNum').value;//获取当前输入的购买数量
    
    if ( buyNum>totalNum ){//如果购买数量大于了库存数量，则给出提示信息，不允许购买，
    
        alert('感谢土豪的支持，但是库存不足哟～');
    }else{//如果购买数量在库存的范围内，则允许购买
    
        //跳转到结算页面去，同时携带上当前商品的购买数量
        window.location.href = 'http://www.home.com/class/day11/code/code14.php?buyNum='+buyNum;
    }
        
};
</script>
</body>
</HTML>
```

第二步，构建名为code14.php的程序处理页面，代码如下

```php
<?php

var_dump( $_GET ); 

echo '<br/>';

var_dump( $_GET['buyNum'] ); 

echo '<br/>';

echo '开始进行结算......'; 
```

第三步，访问code13.html，填写商品数量，测试使用效果，

购买数量超出了库存则不会跳进结算页面，而会直接给个提示信息，

![21](\images\two\img_d11\21.png)

**==小结==**：

1. 表单传值的方式有两种：1）get方式；2）post方式；
2. PHP接收表单数据的方式有3中:1)$_GET; 2)$_POST; 3)$_REQUEST
3. GET方式的核心特征：可以用"?"分隔链接地址和数据；可以用"&"分隔数据与数据；

### 1.3.6 单选按钮与复选框的处理

在web项目中，我们经常会在表单页面构建一些统计选项，以便在后期实现对数据更加精准的定位。常用的统计选项如单选或多选，都是我们经常会用到的。

在表单页面中单选使用的是单选按钮==radio==来实现的；多选使用的复选框==checkbox==来实现的。

### 1.3.7 单选按钮

**==需求==**：实现一个会员注册表单页面，包含帐号，密码和性别三个项，同时实现在程序页面中接收并输出表单页面提交传递的数据。

**==解答==**：

第一步，构建一个名为code15.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>注册会员</title>
</head>
<body>
    <form method="post" action="http://www.home.com/class/day11/code/code16.php" >
        <p>
            <span>帐号：</span>
            <input type="text" name="acc" />
        </p>
        <p>
            <span>密码：</span>
            <input type="password" name="pwd" />
        </p>
        <p>
            <span>性别：</span>
            
            <!-- 单选按钮type值必须为radio -->
            <!-- 必须包含name值，name值是一样的 -->
            <!-- 同时还需指定value值 -->
            男： <input type="radio" name="sex" value="male" />
            女： <input type="radio" name="sex" value="female"/>
            保密： <input type="radio" name="sex" value="secret"/>
        </p>
        <p>
            <input type="submit" value="立即注册" />
        </p>
    </form>
</body>
</HTML>
```

第二步，构建名为code16.php的程序处理页面，代码如下

```php
<?php

var_dump( $_POST ); 
```

第三步，访问code15.html页面，填写注册数据，

![22](\images\two\img_d11\22.png)

第四步，点击提交按钮，查看最终提交后的效果，

![23](\images\two\img_d11\23.png)

**==小结==**：

1. 我们可以通过type值构建为radio来设置单选按钮；
2. 必须包含name值，name值是一样的；
3. 同时还需指定value值；

### 1.3.8 复选框

**==需求==**：实现一个运动网站会员注册表单页面，包含帐号，密码和爱好三个项，其中爱好是多选选项，同时实现在程序页面中接收并输出表单页面提交传递的数据。

**==解答==**：

第一步，构建一个名为code17.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>注册会员</title>
</head>
<body>
    <form method="post" action="http://www.home.com/class/day11/code/code18.php" >
        <p>
            <span>帐号：</span>
            <input type="text" name="acc" />
        </p>
        <p>
            <span>密码：</span>
            <input type="password" name="pwd" />
        </p>
        <p>
            <span>爱好：</span>
            <!-- 在name值后面需要加上中括号"[]" -->
            舞剑： <input type="checkbox" name="hobbies[]" value="wujian" />
            耍大刀： <input type="checkbox" name="hobbies[]" value="shuadadao" />
            游泳： <input type="checkbox" name="hobbies[]" value="swim" />
            跳伞： <input type="checkbox" name="hobbies[]" value="tiaosan" />
        </p>
        <p>
            <input type="submit" value="立即注册" />
        </p>
    </form>
</body>
</HTML>
```

第二步，构建名为code18.php的程序处理页面，代码如下

```php
<?php

echo '<pre>';
print_r( $_POST ); 
```

第三步，访问code17.html页面，填写注册数据，

![img](\images\two\img_d11\24.png?lastModify=1535118571)

第四步，点击提交按钮，查看最终提交后的效果，

![img](\images\two\img_d11/25.png?lastModify=1535118571)

**==小结==**：

1. 复选框需要指定type值为checkbox；
2. 复选框的name值需要加上中括号"[]"；

## 1.4 文件上传

### 1.4.1 概念

#### 1) why使用文件上传

在web领域，文件上传的应用非常广泛。如上传头像，上传证件照，上传报表文件等，都需要用到文件上传技术。

#### 2) what是文件上传

概念：文件上传指的是将文件从本地传输到指定的服务器。

==**提问**==：将文件从本地传输到服务器，从实现的角度来看是一个什么样的过程呢？

#### 3) 文件上传的实现思路

![img](\images\two\img_d11/26.png?lastModify=1535118571)

### 1.4.2 核心步骤

**==需求==**：根据文件上传的3步思路，实现一个图片上传页面及功能。

**==解答==**：

第一步，构建一个名为code19.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>文件上传核心三步</title>
</head>
<body>
    <!-- method必须为post -->
    <!-- 必须指定enctype属性，这个属性的属性值固定是：multipart/form-data -->
    <!-- 必须指定action属性 -->
    <form method="post" encthtml
    ype="multipart/form-data" action="http://www.home.com/class/day11/code/code20.php" >
        <!-- 必须指定type值为file才能够实现文件的点选界面 -->
        上传的图片： <input type="file" name="img" /><br/><br/>
        <input type="submit" value="点击上传" />
    </form>
</body>
</HTML>
```

第二步，构建名为code20.php的程序处理页面，代码如下

```php
//需要使用move_uploaded_file函数实现文件的转移工作
$re = move_uploaded_file($_FILES['img']['tmp_name'], 'F:/home/class/day11/code/upload/a.jpg');
var_dump( $re ); 
```

第三步，访问code19.html页面，选定图片文件，

![img](\images\two\img_d11/28.png?lastModify=1535118571)

第四步，点击提交按钮，查看最终提交后的效果，

![img](\images\two\img_d11/29.png?lastModify=1535118571)

**==小结==**：

1. 以下是$_FILES的基本结构说明：

![img](\images\two\img_d11/27.png?lastModify=1535118571)

==**提问**==：网站项目中，实现文件上传的页面只会支持上传一个文件吗？

#### 1.4.2.1 多文件上传

在web项目中，实现文件上传的页面时常会包含多个文件。

比如家装公司的效果图网站，一个房子内部的效果图不止一张，可能会包含多张，比如会分成客厅效果图，卧室效果图，玄关效果图，厨房效果图等等，那么，在上传文件时就需要支持多文件上传的功能了。

在PHP中我们把多文件上传分成两类：

- 不同名多文件的上传
- 同名多文件的上传

##### 1) 不同名多文件

我们以家装公司的效果图网站来举一个例子。

**==需求==**：

1. 实现一个家装公司效果图网站的图片上传表单页面，包含客厅效果图，卧室效果图两个文件上传域；
2. 实现文件上传的程序处理功能。

**==解答==**：

第一步，构建一个名为code21.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>文件上传核心三步</title>
</head>
<body>
    <form method="post" enctype="multipart/form-data" action="http://www.home.com/class/day11/code/code22.php" >
        客厅效果图： <input type="file" name="keting" /><br/><br/>
        卧室效果图： <input type="file" name="woshi" /><br/><br/>
        <input type="submit" value="点击上传" />
    </form>
</body>
</HTML>
```

第二步，构建名为code22.php的程序处理页面，代码如下

```php
<?php
foreach( $_FILES as $file_key=>$file ){ 

    $path = 'F:/home/class/day11/code/upload/';//定义保存的路径
    $wholeFileName = $path . $file['name'];//拼接全路径名称
    $re = move_uploaded_file($file['tmp_name'], $wholeFileName);

    if( $re ){
        echo $file_key . ' 图片上传成功<br/>'; 
    }
}
```

第三步，访问code21.html页面，选定图片文件，

![30](\images\two\img_d11\30.png)

第四步，点击提交按钮，查看最终提交后的效果，

![1534665181096](D:/PHP/%E5%B0%B1%E4%B8%9A%E7%8F%AD/03%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/day16/day11/doc/img/31)

**==小结==**：不同名多文件的上传指的是html的文件上传域input的name值不相同；



##### 2) 同名多文件

我们以证件审核网站来举一个例子。



**==需求==**：

1. 实现一个证件审核网站的身份证正反两面图片上传表单页面；
2. 实现文件上传的程序处理功能。

**==解答==**：

第一步，构建一个名为code23.html的页面，代码如下

```html
<!DOCTYPE html>
<HTML>
<head>
	<meta charset="UTF-8">
	<title>文件上传核心三步</title>
</head>
<body>
	<form method="post" enctype="multipart/form-data" action="http://www.home.com/class/day11/code/code24.php" >
	<!-- 如果是同名多文件的上传，则必须在name值后面加上中括号"[]" -->
		身份证正面： <input type="file" name="idcard[]" /><br/><br/>
		身份证反面： <input type="file" name="idcard[]" /><br/><br/>
		<input type="submit" value="点击上传" />
	</form>
</body>
</HTML>
```

第二步，构建名为code24.php的程序处理页面，代码如下

```php
<?php
foreach( $_FILES['idcard']['error'] as $error_key=>$error ){ 
    
   $path = 'F:/home/class/day11/code/upload/';//定义保存的路径
   $wholeFileName = $path . $_FILES['idcard']['name'][$error_key];//拼接全路径名称
   $re = move_uploaded_file($_FILES['idcard']['tmp_name'][$error_key], $wholeFileName);

   if( $re ){
        echo '第' . ($error_key+1) . '张图片的全路径为：' . $wholeFileName . '<br/>'; 
   }
}
```

第三步，访问code23.html页面，选定图片文件，

![33](\images\two\img_d11\33.png)

第四步，点击提交按钮，查看最终提交后的效果，



**==小结==**：

多文件上传时$_FILES的结构：

![32](\images\two\img_d11\32.png)

#### 1.4.2.2 封装文件上传函数

在web网站中，文件上传功能不可或缺，但是并不是每一个页面都需要文件上传功能。所以我们会将文件上传功能封装成函数，以便以后在项目中随用随取，而不需要每次都重复写相同的功能代码。



##### 1) error错误码值

在手册中的位置：

![2](\images\two\img_d11\2.png)

![3](\images\two\img_d11\3.png)



##### 2) 功能分析

1. 检查系统方面的错误；
2. 检查逻辑方面的错误；
3. 构建绝对不重复的文件名；
4. 转移文件到指定的目录中；



##### 3) 代码实现

```php
/**
 *  功能：文件上传功能函数
 *  作者：螺旋面条  2018/8/19
 * @param  $file     array       包含五个部分信息的形参变量，
            $file['name']    string      上传文件的原文件名，例：$file['name']='a.jpg';
            $file['type']    string      上传文件的格式类型，例：$file['type']='image/jpeg';
            $file['tmp_name']  string      存储在临时目录下的文件全路径，例：$file['type']='C:/Windows/Temp/xx.tmp';
            $file['error']    int          上传时出现的错误码值，例：$file['error']=0;
                  错误码值：   
                       0     表示没有错误
                       1     文件上传的大小超出了系统配置文件的限制大小
                       2     文件上传的大小超过了浏览器的限制
                       3     文件没有完全上传完
                       4     用户没有选择需要上传的文件
                       6     找不到临时目录
                       7     文件写入服务器失败
            $file['size']     int           文件的大小，单位字节，例：$file['size']=1234567;
 */
function upFile($file){ 
    
    #检查系统错误
    switch ( $file['error'] ){
        case 1:
            echo '文件上传的大小超出了系统配置文件的限制大小～'; 
        return false;
        case 2:
            echo '文件上传的大小超过了浏览器的限制！'; 
        return false;
        case 3:
            echo '文件没有完全上传完！'; 
        return false;
        case 4:
            echo '用户没有选择需要上传的文件哟～'; 
        return false;
        case 6:
            case 7:
            echo '服务器繁忙，请客官稍候再试～'; 
        return false;
    }

    #检查逻辑错误
    //检查格式类型是否符合要求
    $limitType = ['image/jpeg', 'image/png'];//定义出允许的格式类型
    if( !in_array($file['type'], $limitType) ){//如果上传的文件格式类型不在允许的范围内，则给出提示信息，并且中止函数的执行
        echo '您上传的文件格式类型不符合要求，只能上传' . implode('或', $limitType) . '格式的文件'; 
        return false;
    }

    //检查文件的大小是否符合逻辑要求
    $limitSize = 250 * 1024;//限定的大小为250KB
    if( $file['size']>$limitSize ){//如果上传的文件大小超过了限定的大小，则给出提示，并且中止函数的执行
        echo '您上传的文件超过' . ($limitSize/1024) . 'KB的大小，请重新选择上传的文件！'; 
        return false;
    }

    #构建绝对不重复的文件名
    $fileName = uniqid('img_') . date('YmdHis') . '_' . mt_rand(0, 10000) . strstr($file['name'], '.');
    $path = 'F:/home/class/day11/code/upload/';
    $wholeFileName = $path . $fileName;

    #转移文件到指定目录
    $re = move_uploaded_file($file['tmp_name'], $wholeFileName);

    if( $re ){//上传成功
        echo '恭喜你，文件上传成功';
        return true;
    }else{//上传失败
        echo '系统繁忙，请稍候再试！'; 
        return false;
    }
}
```



# 2. MYSQLI扩展

## 2.1 概念

### 2.1.1 why使用

以前操作MYSQL使用的是黑窗口客户端：

```sequence
note left of 黑窗口客户端: 通过黑窗口进行操作
黑窗口客户端-->MYSQL数据库（服务器）:建立连接和认证
MYSQL数据库（服务器）-->黑窗口客户端:返回连接信息
note left of 黑窗口客户端: 通过黑窗口进行操作
黑窗口客户端-->MYSQL数据库（服务器）:执行各种MYSQL操作指令
MYSQL数据库（服务器）-->黑窗口客户端:返回执行的结果
```

现在操作MYSQL需要使用PHP代替黑窗口客户端：

```sequence
note left of PHP: 通过MYSQLI扩展进行操作
PHP-->MYSQL数据库（服务器）:建立连接和认证
MYSQL数据库（服务器）-->PHP:返回连接信息
note left of PHP: 通过MYSQLI扩展进行操作
PHP-->MYSQL数据库（服务器）:执行各种MYSQL操作指令
MYSQL数据库（服务器）-->PHP:返回执行的结果
```



### 2.1.2 what

概念：MYSQLI扩展即PHP利用MYSQL提供的语言操作接口，封装出来的一系列操作MYSQL数据库的==函数==和操作类。 



## 2.2 MYSQLI的使用

MYSQLI是PHP中的一个==扩展==，扩展的意思即不是默认就自带支持的，而是需要通过额外引入才能使用的。



所以我们在使用之前，需要先将MYSQLI扩展引入进PHP。

### 2.2.1 引入MYSQLI

==步骤==：

第一步，打开php的配置文件php.ini，配置extension_dir配置项，

![10](\images\two\img_d12\10.png)

第二步，再在php.ini中开启MYSQLI相关的扩展配置项，

![11](\images\two\img_d12\11.png)

第三步，去到extension_dir指定的目录中确认php_mysqli.dll文件是否存在，

![12](\images\two\img_d12\12.png)

第四步，重启apache，

![13](\images\two\img_d12\13.png)

第五步，测试MYSQLI扩展是否开启成功，通过程序文件中的phpinfo查看配置信息，

![14](\images\two\img_d12\14.png)



### 2.2.2 黑窗口操作

1. 登陆数据库；
2. 设置字符集；
3. 选择默认的数据库；
4. 增删改（设置）数据；
5. 查询操作；



### 2.2.3 连库操作

使用MYSQLI实现连库基本操作  相当于  打开黑窗口连接数据库，选择默认的数据库和设置字符集操作。

| 函数                                                         | 描述                  |
| ------------------------------------------------------------ | --------------------- |
| **mysqli_connect**(数据库ip地址,  帐号,  密码,  默认选择的数据库) | 登陆数据库+选择数据库 |
| **mysqli_set_charset**(mysqli连接,  字符集编码)              | 设置字符集操作        |
| **mysqli_select_db**(mysqli连接, 数据库名)                   | 切换数据库            |
| **mysqli_close**(mysqli连接)                                 | 关闭数据库连接操作    |



> 涉及的函数：
>
> **mysqli_connect**(数据库ip地址,  帐号,  密码,  默认选择的数据库)  
>
> **mysqli_set_charset**(mysqli连接,  字符集编码)
>
> **mysqli_select_db**(mysqli连接, 数据库名) 



**==操作需求1==**：使用MYSQLI实现连接数据库，选择默认的数据库为test，设置字符集为utf8操作。

**==解答==**：构建code1.php程序页面，代码如下

```php
<?php
//连接数据库和选择默认的数据库操作
$link = mysqli_connect('localhost', 'root', '123abc', 'test');
var_dump( $link ); echo '<br/>';
/*
使用mysqli_connect函数所作的操作，相当于以前黑窗口中的
1. 登陆数据库操作；
2. 选择数据库操作；
*/

//设置字符集操作
$re = mysqli_set_charset($link, 'utf8');
/*
使用mysqli_set_charset函数所作的操作，相当于以前黑窗口中的
3. 设置字符集的操作；
*/
var_dump( $re ); 
```



**==操作需求2==**：在"操作需求1"的基础上，实现切换选择数据库为db1数据库操作。

**==解答==**：构建code2.php程序页面，代码如下

```php
<?php

//连接数据库和选择默认的数据库操作
$link = mysqli_connect('localhost', 'root', '123abc', 'test');
var_dump( $link ); echo '<br/>';
/*
使用mysqli_connect函数所作的操作，相当于以前黑窗口中的
1. 登陆数据库操作；
2. 选择数据库操作；
*/

//设置字符集操作
$re = mysqli_set_charset($link, 'utf8');
/*
使用mysqli_set_charset函数所作的操作，相当于以前黑窗口中的
3. 设置字符集的操作；
*/
var_dump( $re ); echo '<br/>';

//切换选择数据库
$re = mysqli_select_db($link, 'db1');
var_dump( $re ); 
```



**==小结==**：

1. mysqli_connect能够实现两个操作，1）连接数据库操作；2）选择数据库操作；





### 2.2.4 设置(增删改)操作

使用MYSQLI实现设置操作  相当于  在黑窗口实现对数据表数据执行增、删、改SQL语句操作。

| 函数                                   | 描述                                          |
| -------------------------------------- | --------------------------------------------- |
| **mysqli_query**(mysqli连接,  sql语句) | 使用MYSQLI实现设置操作增、删、改SQL语句操作。 |



> 涉及的函数：
>
> **mysqli_query**(mysqli连接,  sql语句)



**==操作需求1==**：使用MYSQLI操作day10数据库中的stu3表，实现往数据表stu3中新增一条数据的操作。

**==解答==**：构建code4.php程序页面，代码如下

![15](\images\two\img_d12\15.png)



**==操作需求2==**：使用MYSQLI操作day10数据库中的stu3表，实现修改name为"吕雉"的数据age的值为10。

**==解答==**：构建code5.php程序页面，代码如下

![16](\images\two\img_d12\16.png)



**==操作需求3==**：使用MYSQLI操作day10数据库中的stu3表，删除name为"钟离昧"的数据。

**==解答==**：构建code6.php程序页面，代码如下

![17](\images\two\img_d12\17.png)



**==小结==**：在程序中，我们只需要通过mysqli_query执行增删改的SQL语句，就能够达到增删改数据表中的数据的效果。



### 2.2.5 查询操作

使用MYSQLI实现查询操作  相当于  在黑窗口查询SQL语句操作。

| 函数                                     | 描述                                         |
| ---------------------------------------- | -------------------------------------------- |
| **mysqli_query**(mysqli连接,  sql语句)   | 执行查询语句                                 |
| **mysqli_fetch_assoc**(结果集)           | 每次执行都只能获得一条数据；                 |
| **mysqli_fetch_row**(结果集)             | 获得的是索引下标类型的数组。                 |
| **mysqli_fetch_all**(结果集[, 数组形态]) | 获得的是关联和索引数组.MYSQLI_BOTH/ASSOC/NUM |



> 涉及的函数：
>
> **mysqli_query**(mysqli连接,  sql语句)
>
> **mysqli_fetch_assoc**(结果集)
>
> **mysqli_fetch_row**(结果集)
>
> **mysqli_fetch_all**(结果集[, 数组形态])       数组形态可指定MYSQLI_ASSOC、MYSQLI_NUM（默认值）或MYSQLI_BOTH



==操作需求1==**：使用MYSQLI操作day10数据库中的stu3表，查询age小于14的所有数据，要求得到的每条数据结果是一个关联数组。

**==解答==**：构建code7.php程序页面，代码如下

![18](\images\two\img_d12\18.png)





**==操作需求1小结==**：

1. mysqli_fetch_assoc每次执行都只能获得一条数据；
2. 每次获得的数据是一个关联类型的数组数据，数组元素的下标就是字段名；
3. 当获得玩最后一条数据之后，再次去执行该函数，则只会获得NULL值；







**==操作需求2==**：使用MYSQLI操作day10数据库中的stu3表，查询age小于14的所有数据，要求得到的每条数据结果是一个索引数组。

**==解答==**：构建code8.php程序页面，代码如下

![20](\images\two\img_d12\20.png)

**==小结==**：

1. mysqli_fetch_row获得的是索引下标类型的数组。



**==操作需求3==**：

1. 使用MYSQLI操作day10数据库中的stu3表，查询age小于14的所有数据
2. 要求一次性得到所有数据的结果；
3. 数据结果分别要求输出关联数组数据一份，索引数组数据一份，同时包含关联和索引数组元素的数组一份；

**==解答==**：构建code9.php程序页面，代码如下

```php
<?php

//连接数据库和选择默认的数据库操作
$link = mysqli_connect('localhost', 'root', '123abc', 'day10');

//设置字符集操作
$re = mysqli_set_charset($link, 'utf8');

//查询操作
$sql = "select * from stu3 where age<14";
$result = mysqli_query($link, $sql);//执行查询语句
var_dump( $result ); echo '<hr/>';

//解析结果集对象得到实际数据
//$rows = mysqli_fetch_all($result);//默认得到的是索引类型的所有数据
//echo '<pre>';
//print_r( $rows ); echo '<br/>';
//$rows = mysqli_fetch_all($result, MYSQLI_ASSOC);//指定MYSQLI_ASSOC将会获得关联类型数组的所有数据
//echo '<pre>';
//print_r( $rows ); echo '<br/>';
$rows = mysqli_fetch_all($result, MYSQLI_BOTH);//指定MYSQLI_BOTH将会即包含关联类型数组的数据，又包含索引类型数组的数据
echo '<pre>';
print_r( $rows ); echo '<br/>';
```



**==操作需求3小结==**：

1. 如果我们在项目中需要解析只有一条数据，我们通常用mysqli_fetch_assoc函数；
2. 如果我们在项目中需要一次性解析多条数据，我们通常用mysqli_fetch_all函数；



### 2.2.6 MYSQLI辅助操作函数

| 函数                               | 描述                                   |
| ---------------------------------- | -------------------------------------- |
| **mysqli_field_count**(mysqli连接) | 返回最近一次查询语句查询数据中的总列数 |
| **mysqli_num_fields**(结果集)      | 获得查询的结果集中字段的个数           |
| **mysqli_num_rows**(结果集)        | 获得查询结果集中记录的总行数           |
| **mysqli_insert_id**(mysqli连接)   | 获得最近一次新增数据的主键id值         |
| **mysqli_errno**(mysqli连接)       | 获得错误的错误码值                     |
| **mysqli_error**(mysqli连接)       | 获得错误的错误码值对应的错误信息       |



> 涉及的函数：
>
> **mysqli_field_count**(mysqli连接)	返回最近一次查询语句查询数据中的总列数
>
> **mysqli_num_fields**(结果集)	获得查询的结果集中字段的个数
>
> **mysqli_num_rows**(结果集)	获得查询结果集中记录的总行数
>
> **mysqli_errno**(mysqli连接)		获得错误的错误码值
>
> **mysqli_error**(mysqli连接)		获得错误的错误码值对应的错误信息
>
> **mysqli_insert_id**(mysqli连接) 		获得最近一次新增数据的主键id值



**==操作需求1==**：

1. 使用MYSQLI操作day10数据库中的stu3表，执行两次查询操作；
2. 第一次查询所有数据，但是限制最终只获得2条数据；
3. 第二次查询所有数据，但是限制最终只获得3条数据；
4. 打印出最近一次查询语句查询数据中的总列数；
5. 打印第一次查询结果中的总列数；
6. 打印第一次查询结果集中数据的总行数；

**==解答==**：构建code10.php程序页面，代码如下

```php
<?php

//连接数据库和选择默认的数据库操作
$link = mysqli_connect('localhost', 'root', '123abc', 'day10');

//设置字符集操作
$re = mysqli_set_charset($link, 'utf8');

//查询操作
$sql = "select name, age from stu3 where 1 limit 2";
$result = mysqli_query($link, $sql);

$sql = "select * from stu3 where 1 limit 3";
$result1 = mysqli_query($link, $sql);

//获得最近一次查询出的数据的总列数
$colNum = mysqli_field_count($link);
var_dump( $colNum ); echo '<hr/>';

//打印第一次查询结果中的总列数
$colNum1 = mysqli_num_fields($result);
var_dump( $colNum1 ); echo '<hr/>';

//打印第一次查询结果集中数据的总行数
$rowNum = mysqli_num_rows($result);
var_dump( $rowNum ); 
```



**==操作需求1小结==**：

mysqli_field_count是获得最近一次查询结果的总列数；mysqli_num_fields是获得指定某一次查询结果集包含数据的总列数；mysqli_num_rows是获得指定某一次查询结果集包含数据的总行数；



**==操作需求2==**：

1. 使用MYSQLI执行连库操作，要求要连库成功；同时执行设置字符集操作，要求设置的字符集为"utf8888"，使得设置字符集操作失败；
2. 打印出MYSQLI操作失败的错误信息；
3. 打印出MYSQLI操作失败错误信息对应的错误码值；

**==解答==**：构建code11.php程序页面，代码如下

![21](\images\two\img_d12\21.png)



**==操作需求2小结==**：

1. mysqli_error可以获得出错的原因大致范围；mysqli_errno可以获得错误信息对应的错误码值；



**==操作需求3==**：

1. 使用MYSQLI操作day10数据库中的goods_info表，向数据表中新增一条数据；
2. 打印出最近一次新增数据时的主键id；

**==解答==**：构建code12.php程序页面，代码如下

![22](\images\two\img_d12\22.png)



**==操作需求3小结==**：

mysqli_insert_id可以获得最近一次新增数据的主键id值。





# 3. HTTP协议

## 3.1 概念

### 3.1.1 why学习HTTP协议

浏览器访问网站页面时，走的都是==HTTP协议==，如以下截图红框所示部分，标明的就是HTTP协议。

![1](\images\two\img_d13\1.png)

作为一个将要从事web项目开发工作的开发者，对HTTP协议需要有一个基本的了解。



### 3.1.2 what是HTTP协议

**HTTP**：Hyper Text Transfer Protocol  中文翻译为 "超文本传输协议"。

 

Mr ZHANG是英国人，只会说英语；宫本是日本人，只会说日语；两人想要相互沟通交流，如果都各自使用本国语言，那么对方都将听不懂。

为了能够让两个人无障碍相互沟通交流，让Mr ZHANG和宫本都学会中文，那么，两人就都能够使用中文进行交流了。而中文在这里就变成了两人之间沟通的一个协议。这个协议规定了两方向对方说话，按照某种语法来表达一个具体的意思。

```sequence
Mr ZHANG(英国人)-->宫本（日本人）: 使用中文说："早上好！" 问候宫本
Mr ZHANG(英国人)-->宫本（日本人）: 使用中文说："早上好！" 问候宫本
note right of 宫本（日本人）:宫本按照中文的语法\n来理解"早上好！"的意思
宫本（日本人）-->Mr ZHANG(英国人): 使用中文说："早上好！" 回复Mr ZHANG
note left of Mr ZHANG(英国人):Mr ZHANG按照中文的语法\n来理解"早上好！"的意思
```

而在web项目中，是浏览器和服务器之间进行交互的一个过程。也就意味着浏览器与服务器两方要通话。

而浏览器和服务器本身并不是同类，双方之间要想互相说话让对方听的明白，可以让双方都支持一个第三方的规定，通过这个规定来进行沟通交流。那么，HTTP协议，就是浏览器和服务器之间沟通的这个规定。

```sequence
浏览器-->服务器: 使用HTTP协议规定的格式\n发出请求
note right of 服务器:服务器按照HTTP协议规定的格式\n解析并处理请求内容
服务器-->浏览器: 使用HTTP协议规定的格式\n返回响应
note left of 浏览器:浏览器按照HTTP协议规定的格式\n解析并处理响应内容
```



**概念**：HTTP协议，就是一种==规定==，它规定了浏览器请求服务器时，需要用什么样的格式发送请求数据；也规定了服务器响应浏览器时，需要用什么样的格式回应响应数据；这些对**数据格式的规定**就是HTTP协议。



## 3.2 HTTP协议分类

HTTP协议的分类包含两种：

- [x] HTTP请求
- [x] HTTP响应



### 3.2.1 HTTP请求

TIPS：我们可以理解成就是浏览器和服务器说的话。

包含四个组成部分：1）请求行；2）请求头；3）空白行；4）请求数据 

**==图例==**：

![3](\images\two\img_d13\3.png)



#### 1) 请求行

包含基本的请求信息部分。

**==图例==**：

![4](\images\two\img_d13\4.png)



#### 2) 请求头

由一个一个的==请求协议项==组成。

**==图例==**：

![5](\images\two\img_13\5.png)



**常见的请求头协议项**：

> **host**：当前url中所要请求的服务器的主机名（域名）
> **accept-encoding**：是浏览器发给服务器,声明浏览器支持的压缩编码类型  比如gzip
> **accept_charset**：表示浏览器支持的字符集
> **==referer==**：表示，此次请求来自哪个网址
> **accept-language**：可以接收的语言类型，cn，en等
> **cookie**：如果之前当前请求的服务器在浏览器端设置了数据（cookie），那么当前浏览器再次请求该服务器的时候，就会把对应的数据带过去
> **user-agent**：用户代理，当前发起请求的浏览器的内核信息
> **accept**：表示浏览器可以接收的数据类型
> **content-length**（==post==）：只有post提交的时候才会有的请求头，显示的是当前要提交的数据的长度（字节）
> **if-modified-since**（==get==）：表示，在客户端向服务器请求某个资源文件时，询问此资源文件是否被修改过
> ==**content-type**==（==post==）：用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件



#### 3) 空白行

专门用于分隔请求头和请求数据的结构。

**==图例==**：

![6](\images\two\img_13\6.png)



#### 4) 请求数据

只有当==post方式==提交数据时才会存在。

![7](\images\two\img_13\7.png)



------



### 3.2.2 HTTP响应

包含四个组成部分：1）状态行；2）响应头；3）空白行；4）响应数据 

**==图例==**：

![8](\images\two\img_13\8.png)



#### 1) 状态行

包含基本的响应信息部分。

**==图例==**：

![9](\images\two\img_13\9.png)



**响应状态码**

1xx：表示请求尚未完成；

2xx：表示请求和响应都没有问题；

3xx：表示重定向；

4xx：表示请求出现问题，响应失败；

5xx：表示服务器出现问题，响应失败；



**常见的响应状态码**：

200  表示请求和响应完全没有问题

301和302：表示永久重定向和临时重定向；    

404：表示请求的文件丢失或者找不到

500：表示服务器环境出现了问题



#### 2) 响应头

由一个一个的响应协议项组成。

**==图例==**：

![10](\images\two\img_13\10.png)



**常见的响应头协议项**：

> **server**：服务器主机信息
>
> **date**：响应时间
>
> **last-modified**：文件最后修改时间（对应请求中：if-modified-since）
>
> **content-length**：响应主体的长度（字节）
>
> **content-type**：响应内容的数据类型：text/html，image/png等
>
> ==**location**==：重定向，浏览器遇到这个选项，就立马跳转（不会解析后面的内容）
>
> ==**refresh**==：重定向（刷新），浏览器遇到这个选项就会准备跳转，刷新一般有时间限制，时间到了才跳转，浏览器会继续向下解析
>
> **content-encodeing**：文件编码格式
>
> **cache-control**：缓存控制，no-cached不要缓存



#### 3) 空白行

专门用于分隔响应头和响应数据的结构。

**==图例==**：

![11](\images\two\img_13\11.png)



#### 4) 响应数据

包含完整的返回给浏览器的内容。

**==图例==**：![12](\images\two\img_13\12.png)





------



## 3.3  HTTP协议特点

1) 不仅支持B/S模式，还支持C/S模式。

2) 灵活，支持任意类型的数据。

3) ==无连接特性==，指的是每次完整的请求之后，本次连接要断开。

4) ==无状态特性==，HTTP协议对会话过程中产生的数据不具有记忆能力。



## 3.4 HTTP协议的应用

### 3.4.1 跳转

**==需求==**：实现访问A页面就直接跳转到B页面的效果。

**==解答==**：构建一个名为code2.php的程序文件，代码如下：

```php
<?php

echo '当前文件名叫code2.php';

header('Location:http://www.home.com/class/day13/code/code3.php');
```

构建一个名为code3.php的程序文件，代码如下：

```php
<?php

echo '当前文件名叫code3.php';
```

访问code2.php，浏览器展示的效果为：

![13](\images\two\img_13\13.png)



**==小结==**：

1. 使用header指定Location跳转，并不是从服务器就直接跳转了，而是先将Location协议项响应给浏览器，再由浏览器重新向服务器发出新的请求来实现跳转效果的。



### 3.4.2 刷新跳转

**==需求==**：实现访问A页面，在A页面停留3秒钟展示提示信息"别眨眼，3秒后我就要跳转了！"，3秒后再跳转到B页面。

**==解答==**：构建一个名为code4.php的程序文件，代码如下：

```php
<?php
echo '别眨眼，3秒后我就要跳转了！';
header('Refresh:3; url=http://www.home.com/class/day13/code/code5.php');
```

构建名为code5.php的程序文件，代码如下：

```php
<?php
echo '这是code5';
```

访问code4.php的效果：



### 3.4.3 SSL安全访问协议

#### 1) https简介

HTTPS  即  Secure Hypertext Transfer Protocol  翻译为中文：**安全的超文本传输协议**



> 它是由Netscape开发并**内置于其浏览器中**，用于**对数据进行压缩和解压操作**，**并用于网络传输**的一种技术。
>
> HTTPS实际上应用了Netscape的完全套接字层（SSL）作为HTTP应用层的子层。（==HTTPS使用端口443==，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用**X.509**数字认证，如果需要的话用户可以确认发送者是谁。
>
> https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，https的安全基础是SSL。
>
> 它是一个URI scheme(抽象标识符体系)，句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。



#### 2) 配置SSL协议

**==目标==**：使用  https://www.t1.com/t.php  访问 day13/code目录中  的t.php文件。

**==步骤==**：

第一步，将day13/source目录下的key文件夹拷贝到apache安装目录下的**conf目录**中

![14](\images\two\img_13\14.png)

拷贝到下图所示的目录中

![15](\images\two\img_13\15.png)

第二步，打开apache的配置文件httpd.conf，开启mod_socache_shmcb 和mod_ssl模块，同时开启引入ssl配置文件，

去掉下图中引入模块的注释，开启模块引入配置，

![16](\images\two\img_13\16.png)

引入ssl配置文件，

![17](\images\two\img_13\17.png)

第三步，调整apache安装目录下的extra/httpd-ssl.conf配置文件SSLSessionCache配置项的路径，同时注释VirtualHost示例，

调整如下图所示的路径：

![18](\images\two\img_13\18.png)

注释掉如下图所示的配置项：将122行到291行全部注释掉

![19](\images\two\img_13\19.png)



第四步，打开虚拟主机配置文件，增加如下虚拟主机配置项：

```mysql
#ssl默认监听的端口是443，所以如果要使用默认的端口，就不能再使用80，而应该使用443端口
<VirtualHost *:443>
#开启SSL引擎的支持
	SSLEngine on
#指定支持的SSL协议版本
	SSLProtocol all -SSLv2 -SSLv3
#SSL加密计算的方式
	SSLCipherSuite HIGH:MEDIUM:!aNULL:!MD5
#认证证书文件
	SSLCertificateFile "F:/usr/apache24/conf/key/server.crt"
#证书私钥
	SSLCertificateKeyFile "F:/usr/apache24/conf/key/server.key"
#根证书
	SSLCertificateChainFile "F:/usr/apache24/conf/key/ca.crt"
	DocumentRoot "F:/home/class/day13/code"
	ServerName www.t1.com
	<Directory />
	Options +Indexes +FollowSymLinks +ExecCGI
	AllowOverride All
	Order allow,deny
	Allow from all
	Require all granted
	</Directory>
</VirtualHost>
```



第五步，重启apache，向hosts文件中新增如下配置，

![20](\images\two\img_13\20.png)

在hosts文件中增加如下配置，(C:/Windows/system32/drivers/etc/hosts)

```
127.0.0.1  www.t1.com
```



第六步，在day13/code目录中创建名为t.php的程序文件，代码如下

```php
<?php
echo '灭嘿嘿嘿！HTTPS被我搞掂了～';
```



第七步，在浏览器中使用  https://www.t1.com/t.php  访问t.php，测试使用效果

![21](\images\two\img_13\21.png)





------



# 4. 文件编程

## 4.1 概念

### 4.1.1 why使用

在web项目中，文件编程的应用相当广泛，比如：文件下载（软件，电影，照片....），生成报表文件并支持下载功能等都需要使用到文件编程技术。



### 4.1.2 what

所谓的文件编程技术，指的就是对==文件==或==目录==的==增删改查==操作！



## 4.2 文件编程分类

- [x] 对目录的操作
- [x] 对文件的操作



### 4.2.1 对目录操作

**设置操作**（增删改）

> 涉及的函数：
>
> **mkdir**(新目录名[,  目录权限[,  是否递归创建]])      创建一个目录（make directory）
>
> **rmdir**(目录全路径)      删除一个目录（remove directory）
>
> **rename**(旧名字,  新名字)     给目录改名或转移目录



**==操作需求1==**：在code目录中执行创建目录操作，要求：

1. 创建名为dir1和dir2两个目录；
2. 递归创建dir3/dir3_1/dir3_1_1目录；

**==解答==**：构建一个名为code6.php的程序文件，代码如下：

```php
//创建dir1目录和dir2目录
$re = mkdir('./dir1');
var_dump( $re ); echo '<br/>';

$re = mkdir('F:/home/class/day13/code/dir2');
var_dump( $re ); 

//递归创建目录dir3/dir3_1/dir3_1_1
//$re = mkdir('./dir3/dir3_1/dir3_1_1');//默认情况下是不支持的
//var_dump( $re ); 

$re = mkdir('./dir3/dir3_1/dir3_1_1', 0777, true);//把第三个参数设置为true，就可以递归的去创建目录及目录下的子目录
var_dump( $re ); 
```

**==操作需求1小结==**

1. 我们可以使用mkdir函数创建一个目录；
2. 如果我们要递归的创建目录及目录中的子目录，则需要指定第三个参数为true；



**==操作需求2==**：在code目录中执行修改目录操作，要求：

1. 将dir1的目录名改为dir100；
2. 将dir2目录转移到dir3目录中，并且重命名为dir200；

**==解答==**：构建一个名为code7.php的程序文件，代码如下：

```php
#将dir1的目录名改为dir100
$re = rename('./dir1', './dir100');
var_dump( $re ); 

#将dir2目录转移到dir3目录中，并且重命名为dir200
$re = rename('./dir2', './dir3/dir200');
```

**==操作需求2小结==**

1. 我们可以使用rename函数修改目录的名字；
2. 我们还可以使用rename将某个目录转移到另外一个目录中；



**==操作需求3==**：在code目录中执行删除目录操作，要求：

1. 将dir100删除；
2. 尝试将dir3目录删除；

**==解答==**：构建一个名为code8.php的程序文件，代码如下：

```php
#将dir100删除
$re = rmdir('./dir100');
var_dump( $re ); 

#尝试将dir3目录删除
$re = rmdir('./dir3');
var_dump( $re ); 
```



**==操作需求3小结==**

1. 我们可以使用rmdir删除某个目录；
2. 删除的目录必须是没有内容的目录才能成功删除；



**查询操作**

> 涉及的函数：
>
> **opendir**(目录全路径)      打开一个目录
>
> **readdir**(打开的目录资源)      读取目录中的内容
>
> **closedir**(打开的目录资源)     关闭一个打开的目录



**==操作需求==**：查询code下的demo目录，要求：

1. 读取并输出该目录下的所有文件的文件名；

**==解答==**：构建一个名为code9.php的程序文件，代码如下：

```php
#打开一个目录
$op = opendir('./demo');
var_dump( $op ); echo '<br/>';

#读取目录内容
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第1次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第2次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第3次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第4次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第5次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第6次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第7次执行readdir的输出
$rd = readdir($op);
var_dump( $rd ); echo '<br/>';//第8次执行readdir的输出
```

访问code9.php输出的内容：

```mysql
resource(3) of type (stream)   #输出打开的目录资源$op的内容
string(1) "."                  #第1次执行readdir的输出
string(2) ".."                 #第2次执行readdir的输出
string(11) "article.txt"       #第3次执行readdir的输出
string(4) "dir1" 			  #第4次执行readdir的输出
string(4) "dir2" 			  #第5次执行readdir的输出
string(4) "dir3" 			  #第6次执行readdir的输出
bool(false) 				  #第7次执行readdir的输出
bool(false) 				  #第8次执行readdir的输出
```



**==操作需求小结==**

1. 需要先使用opendir打开一个目录；
2. 然后再使用readdir读取打开的资源中的内容；



**查询辅助操作**

> 涉及的函数：
>
> ==**realpath**==(路径)      将给定的路径转换为绝对路径地址
>
> **==basename==**(路径)      返回当前给定路径的基础文件（或文件夹）名部分
>
> ==**dirname**==(路径)      返回当前给定路径的目录部分
>
> **is_dir**(全路径)      判断一个给定文件是否是一个目录



**==操作需求==**：在code目录下对相对路径"./"进行操作，要求：

1. 将相对路径"./"转换为绝对路径，并将转换后的结果输出；
2. 获得"1"中转换的绝对路径中的基础文件名并将其输出；
3. 获得"1"中转换的绝对路径中的目录部分并将其输出；
4. 判定"./code1.php"是否是一个目录；
5. 判定"./dir3"是否是一个目录；

**==解答==**：构建一个名为code10.php的程序文件，代码如下：

```php
#1. 将相对路径"./"转换为绝对路径
$path = realpath('./');
var_dump( $path ); echo '<br/>';

#2. 获得"1"中转换的绝对路径中的基础文件名
$basename = basename($path);
var_dump( $basename ); echo '<br/>';

#3. 获得"1"中转换的绝对路径中的目录部分
$dirname = dirname($path);
var_dump( $dirname ); echo '<br/>';

#4. 判定"./code1.php"是否是一个目录
$re = is_dir('./code1.php');
var_dump( $re ); echo '<br/>';

#5. 判定"./dir3"是否是一个目录
$re = is_dir('./dir3');
var_dump( $re ); 
```

访问code10.php输出的结果：

```mysql
string(24) "F:\home\class\day13\code"   #第 1 点的输出
string(4) "code"   					   #第 2 点的输出
string(19) "F:\home\class\day13" 	    #第 3 点的输出
bool(false) 						  #第 4 点的输出，为false表示不是一个目录
bool(true)							  #第 5 点的输出，为true表示是一个目录
```

**==操作需求小结==**

1. realpath将相对路径专为绝对路径；
2. basename将会获得一个路径的基础文件名部分；
3. dirname将会获得一个路径的目录部分；



### 4.2.2 对文件操作

因php版本更替原因，在php中对文件的操作分为两类：

- [ ] php4相关文件操作
- [ ] php5相关文件操作



**PHP4相关文件操作**

涉及的函数：

> **fopen**(文件全路径,  打开模式)    打开一个文件
>
> **fread**(打开的文件资源,  读取内容的长度)    读取文件中的内容
>
> **fwrite**(打开的文件资源,  写入的内容)    向文件中写入内容
>
> **fclose**(打开的文件资源)    关闭打开的文件
>
> **filesize**(文件全路径)  获取文件的大小



**==操作需求==**：操作code目录下的article.txt文件，要求：

1. 将文件中的所有内容读取并输出；
2. 向文件中最末尾写入"这是一篇好文章"；
3. 关闭打开的文件；

**==解答==**：构建一个名为code11.php的程序文件，代码如下：

```php
#读取文件的内容
//$fp = fopen('./article.txt', 'r');//打开一个文件，如果指定r模式，则为只读模式
$fp = fopen('./article.txt', 'a+');//打开一个文件
var_dump( $fp ); echo '<br/>';

$size = filesize('./article.txt');//获得指定文件的大小，单位是字节
var_dump( $size ); echo '<br/>';

$content = fread($fp, $size);//读取文件中的所有内容
echo $content; echo '<br/>';

#往文件中写入内容
$con = '这是一篇好文章';
$re = fwrite($fp, $con);//往文件中写入内容
var_dump( $re ); echo '<br/>';

#关闭打开的文件
$re = fclose($fp);
var_dump( $re ); echo '<br/>';
var_dump( $fp ); 
```



**==小结==**：

1. 我们能对之后打开的文件做什么样的操作，取决于fopen打开文件是指定的第二个参数是什么模式。



### 4.2.3 PHP5相关文件操作

涉及的函数：

> **file_put_contents**(文件全路径,  写入的内容[,  写入方式])      向文件中写入内容   ​写入方式可指定为FILE_APPEND
>
> **file_get_contents**(文件全路径)      获得文件中的内容



**==演示案例==**：读取article.txt文件中的内容，并且向article.txt文件中写入"好酒哇！"内容

实现：构建名为code12.php的程序文件，代码如下：

```php
<?php

#读取文件中的内容
$contents = file_get_contents('./article.txt');

echo $contents; echo '<hr/>';

#向文件中写入内容
$target = '好酒哇！';
//$re = file_put_contents('./article.txt', $target);//不指定第三个参数，则默认是覆盖写入
$re = file_put_contents('./article.txt', $target, FILE_APPEND);//如果指定第三个参数为FILE_APPEND则表示是追加写入
var_dump( $re ); 
```



**==小结==**：在写入内容是如果不指定第三个参数，则默认是覆盖写入；如果要实现追加写入，则需要指定第三个值为FILE_APPEND。



## 4.3 案例：文件下载

**==操作需求==**：实现文件下载功能，要求：

1. 通过下载页面可以下载code/dw目录中的txt文件和zip文件；
2. 下载txt文件指定默认的新名字为a.txt；zip文件指定默认的新名字为b.zip；

**==步骤==**：

第一步，构建名为code13.php的程序页面，代码如下：

```html
<!DOCTYPE html>
<HTML>
<head>
    <meta charset="UTF-8">
    <title>文件下载</title>
</head>
<body>
    <a href="http://www.home.com/class/day13/code/code14.php?type=1">下载txt文件</a>
    <a href="http://www.home.com/class/day13/code/code14.php?type=2">下载zip文件</a>
</body>
</HTML>
```

第二步，构建名为code14的程序处理页面，代码如下：

```php
<?php

if( $_GET['type']==1 ){//表示需要下载txt文件

    $oriFileName = './dw/article.txt';//原始文件的全路径
    $newFileName = 'a.txt';//下载之后的新名字

}elseif( $_GET['type']==2 ){//表示需要下载zip文件

    $oriFileName = './dw/fscp.zip';
    $newFileName = 'b.zip';
}

//表示 服务器告诉浏览器  接下来响应给浏览器你的内容类型是文件流的数据类型
header('Content-type:application/octet-stream');

//表示 服务器告诉浏览器 接下来响应给你浏览器的内容需要当成附件（文件）的形式来对待，这个附件的新名字为filename所指定的名称
header("Content-disposition:attachment; filename={$newFileName}");

//这个是最终将会输出给浏览器的内容
echo file_get_contents($oriFileName);
```

第三步，测试使用效果：

访问code13.php，点击下载txt文件，

![22](\images\two\img_13\22.png)

点击之后，弹出上图所示下载框，新名字为a.txt，

然后选择下载路径，直接下载，

![23](\images\two\img_13\23.png)



------





------

# 5.会话技术

## 5.1 概念

### 5.1.1 why使用会话技术

1)我们访问网站走的是HTTP协议，协议具有无连接无状态的特性，对事物的处理不具有记忆能力；

2)我们在web项目中，很多时候需要将会话数据记忆存储，以便后续的程序能够随时调用和使用；

在web项目中我们可以通过会话技术解决以上问题。



### 5.1.2 what是会话技术

通俗的讲：会话技术就是浏览器和服务器“唠嗑”。

**==概念==**：在web页面访问过程中，使访问过程中产生的数据持久化存储的一种技术。



## 5.2. 会话技术分类

- [ ]  COOKIE技术；

- [ ]  SESSION技术；



## 5.3 COOKIE技术

**概念**：将数据持久化存储在**浏览器端**，并且能够**使数据标识服务器**的一种技术。



### 5.3.1 基本操作

#### 1) 设置操作 (增删改)

------

涉及函数：

> **setcookie**(名,  值)       设置COOKIE数据



**==需求==**：分别实现增、删、改COOKIE数据的操作，要求

1. 访问code1.php文件，实现新增一条COOKIE数据，名为：name，值为：zhangsan；
2. 访问code2.php文件，实现修改"1"中新增的COOKIE数据，新值为：lisi；
3. 访问code3.php文件，实现删除COOKIE数据name；



**==解答==**：

1. 构建名为code1.php的程序文件，代码如下：

```php
<?php
#1.新增COOKIE数据
$re = setcookie('name', 'zhangsan');
var_dump( $re ); 
```

访问code1.php, 效果为：

![4](\images\two\img_d14\4.jpg)



------

2. 构建名为code2.php的程序文件，代码如下：

```PHP
<?php
#1.修改COOKIE数据   名不变，值改变
$re = setcookie('name', 'lisi');
var_dump( $re ); 
```

访问code2.php, 效果为：

![5](\images\two\img_d14\5.jpg)



------

3. 构建名为code3.php的程序文件，代码如下：

```php
<?php
#1.删除COOKIE数据   名不变，值变为空字符串
$re = setcookie('name', '');
var_dump( $re ); 
```

访问code3.php, 效果为：

![6](\images\two\img_d14\6.jpg)

**==小结==**：

我们只需要统一使用setcookie函数来进行增、删、改COOKIE数据的操作即可。

------

#### 2) 查看操作

使用$_COOKIE 变量来操作



**==需求==**：分别查看COOKIE数据的操作，要求

1. 访问code4.php文件，实现新增两条COOKIE数据，第一条名为：name，值为：wangwu，第二条名为：age，值为：16；
2. 访问code5.php文件，实现新增一条COOKIE数据名为：height，值为：1.78，同时查看并打印所有的COOKIE数据；
3. 访问code6.php文件，查看并打印出所有的COOKIE数据；

**==解答==**：

1. 构建名为code4.php的程序文件，代码如下：

```php
<?php
#新增两条COOKIE数据
$re = setcookie('name','wangwu');
var_dump($re);echo "<br>";

$re = setcookie('age',16);
var_dump($re);
```

访问code4.php, 效果为：

![7](\images\two\img_d14\7.jpg)



------

2. 构建名为code5.php的程序文件，代码如下：

```php
<?php
#新增一条COOKIE数据
setcookie('height', 1.78);

#打印所有的COOKIE数据，需要使用$_COOKIE
var_dump( $_COOKIE ); 
```

访问code5.php, 效果为：

![8](\images\two\img_d14\8.jpg)



------

3. 构建名为code6.php的程序文件，代码如下：

```php
<?php 
	echo "<pre>";
	#打印所有的COOKIE数据，需要使用$_COOKIE
	var_dump($_COOKIE);
```

访问code6.php, 效果为：

![9](\images\two\img_d14\9.jpg)



**==小结==**：我们需要通过$_COOKIE实现查看COOKIE数据；



------



**==提问==**：在访问code4.php时首先生成了两条COOKIE数据，然后再访问code5.php时在程序中又新增了一条COOKIE数据，按道理来说一共现在有3条COOKIE数据，但是访问code5.php时只打印出了code4.php中生成的2条，然而，再访问新的文件code6.php时却能够打印三条，为什么呢？



### 5.3.2 基本原理

**==原理图==**：

![10](\images\two\img_d14\10.png)



**==小结==**：通过分析以上原理图，我们了解到：

1. COOKIE数据是存储在**浏览器**的；
2. 如果浏览器存在和某台服务器之前会话时产生过的COOKIE数据，那么在以后的请求当中，将会把所有的COOKIE数据跟着请求一并携带去服务器；



### 5.3.3 setcookie与$_COOKIE的关系

**==关系图==**：

![11](\images\two\img_d14\11.png)



**==小结==**：

1. **setcookie**只是负责在响应浏览器时，**告诉浏览器**接下来需要去设置一条什么样的COOKIE数据的，setcookie函数是**不会去直接操作到$_COOKIE变量**；

2. 每次执行程序之前，将会由**PHP自动初始化$_COOKIE变量**；如果请求时，有携带浏览器传递过来的COOKIE数据，则把这些数据初始化给$\_COOKIE变量；如果请求时，浏览器没有传递任何COOKIE数据过来，则将把

   $_COOKIE初始化成空数组；





### 5.3.4 属性设置

setcookie除了前两个参数表示名和值之外，还有五个属性相关的参数，分别是： 

> **setcookie**(名, 值, **有效期**，**有效路径**，**有效域**，**是否安全传输**，**httponly**);



#### 1) 有效期

------

**要点**：

- 通过setcookie函数的**第三个**参数来进行设置的；
- **不设置**或**设置为0**表示**默认**情况，为一个会话周期；
- **默认**情况一个会话周期为从新增该条COOKIE到**浏览器关闭**为止。



**==需求==**：

1. 新增一条COOKIE数据，名为：name1，值为：zhaoliu；同时设置这条COOKIE数据的有效期为当前时间过3秒失效。

**==解答==**：构建名为code7.php的程序文件，代码如下：

```php
<?php
#设置COOKIE数据的有效期
setcookie('name1', 'zhaoliu', time()+3);//这个有效期的意思是 从当前时间到过3秒过期
setcookie('name', 'zhangsan');
```

访问code7.php，观察监控面板效果：

访问时，生成的COOKIE数据

![10](\images\two\img_d14\10.jpg)

3秒后，刷新监控面板，发现被浏览器自动清除了，说明有效期生效

![13](\images\two\img_d14\13.jpg)



**==小结==**：

1. 我们可以通过第三个参数设置有效期；
2. 如果我们将第三个参数的有效期设置为一个过期的时间戳，则效果和删除一条COOKIE数据的效果一致。





#### 2) 有效路径

------

**要点**：

- 通过setcookie函数的**第四个**参数来进行设置的；
- **不设置**或**设置为空字符串**表示**默认**情况；
- 默认情况表示当前程序**所在目录**及**其子目录**有效。



**==需求==**：在code目录中创建名为code9.php的程序文件，新增2条COOKIE数据，

1. 第一条名为：name2，值为：zhaoliu2，不设置其他属性；第二条名为：name3，值为：zhaoliu3，要求这条COOKIE数据的有效路径为"/"；
2. 在当前目录中新建一个新目录demo1，在新目录中创建一个新的程序文件code_demo.php，打印出所有能够获得的COOKIE数据；
3. 在code目录的上级目录中创建一个新的程序文件code_up.php，打印出所有能够获得的COOKIE数据；



**==解答==**：

1. 在code目录下构建名为code9.php的程序文件，代码如下：

```php
<?php
#有效路径
setcookie('name1', 'zhaoliu1');
setcookie('name2', 'zhaoliu2', 0, '/');
```

访问code9.php，观察监控面板效果：

![14](\images\two\img_d14\14.jpg)



------

2. 在code新建一个新目录demo1，并且在新目录中创建一个新的程序文件code_demo.php，代码如下：

```php
<?php
var_dump( $_COOKIE ); 
```

访问code_demo.php文件，观察打印效果：

![15](\images\two\img_d14\15.png)





------

3. 在code目录的上级目录创建一个新的程序文件code_up.php，代码如下

![16](\images\two\img_d14\16.jpg)



**==小结==**：

1. 通过第四个参数设置有效路径；
2. 如果将有效路径设置为"/"表示网站根目录及其子目录下都能访问；



------



#### 3) 有效域

**要点**：

- 通过setcookie函数的**第五个**参数来进行设置的；
- **不设置**或**设置为空字符串**表示**默认**情况；
- **默认**情况表示**当前域名**及**其子域名**有效。



**==需求==**：完成以下要求：

1. 配置一个新的域名"test.code.com"和已有的www.code.com域名指向相同的目录；
2. 构建名为code10.php的程序文件，使用www.code.com域名访问，实现新增两条COOKIE数据，第一条名为：name4，值为：zhaoliu4，不设置其他属性；第二条名为：name5，值为：zhaoliu5，要求这条COOKIE数据的有效域为"code.com"；
3. 构建code11.php文件，在文件中实现打印所有COOKIE数据操作，观察使用www.code.com访问时的效果和test.code.com访问时的效果；



**==解答==**：

1. 首先打开apache的虚拟主机配置文件，新增test.home.com虚拟主机域名配置项，参照www.home.com的配置，如下图所示，

![17](\images\two\img_d14\17.jpg)



------

2. 构建名为code10.php的程序文件，代码如下：

```php
<?php 
    #有效路径
	setcookie('name4','zhaoliu4');
	setcookie('name5','zhaoliu5',0,"","code.com");
```

使用www.code.com域名访问code10.php，观察监控面板效果：

![18](\images\two\img_d14\18.jpg)



**tips**:  www.code.com 和 test.code.com 为 code.com的子域名

------

3. 构建名为code11.php的程序文件，代码如下：

```php
<?php 
	echo "<pre>";
	var_dump($_COOKIE);
```

 1）使用www.code.com访问，效果为：

![19](\images\two\img_d14\19.jpg)



2)使用test.home.com访问，效果为：

![20](\images\two\img_d14\20.jpg)

tips： test.home.com 和 www.code.com 同级 所以访问不到



**==小结==**：有效域最多只能设置到网站的根目录。



------

#### 4) 是否安全传输

**要点**：

- 通过setcookie函数的**第六个**参数来进行设置的；
- **不设置**或**设置为false**表示默认情况；
- **默认**情况表示**http或https下都有效**，如果将值设置为true,则表示只有在https下才有效（包括增删改查）。



**==需求==**：完成以下要求：

1. 在day14/code/code13.php新增1条COOKIE数据，名为：name6，值为：zhaoliu6，将是否安全传输出行设置为true，使用http://www.home.com域名访问，查看执行效果；
2. 在day13/code/code_day4.php新增1条COOKIE数据，名为：name6，值为：zhaoliu6，将是否安全传输出行设置为true，使用https://www.t1.com域名访问，查看执行效果；



**==解答==**：

1. 在day14/code构建名为code13.php的程序文件，代码如下：

```php
<?php 
	setcookie('name6','zhaoliu6',0,"","",true);
```

1）使用http://www.home.com域名访问code13.php，观察监控面板效果：

![21](\images\two\img_d14\21.jpg)



2)使用https://www.t1.com域名访问code_day4.php，观察监控面板效果：

![22](\images\two\img_d14\22.png)



**==小结==**：如果只是想在https下设置COOKIE成功，则需要将第六个参数设置为true。



------

#### 5) httponly

**要点**：

- 通过setcookie函数的**第七个**参数来进行设置的；
- **不设置**或**设置为false**表示默认情况；
- **默认**情况表示除了能够使用原程序脚本代码访问以外，**还能够通过其他脚本语言访问到COOKIE数据**。如果设置为true，则表示**只**允许原程序脚本代码进行操作。



**==需求==**：实现如下操作，要求：

1. 构建code14.php程序文件，新增三条COOKIE数据，第一条数据名为：name，值为：zhangsan；第二条数据名为：age，值为：16；第三条数据名为：name1，值为：zhaoliu1，要求第三条数据设置httponly属性为true；

2. 构建code15.php程序文件，使用PHP打印出所有的COOKIE数据；同时使用javascript代码也打印能够获取的COOKIE数据；

   

**==解答==**：

1. 构建code14.php，代码如下：

```php
<?php
setcookie('name', 'zhangsan');
setcookie('age', 16);
setcookie('name1', 'zhaoliu1', 0, '', '', false, true);//第七个参数为控制httponly属性的
```

访问code14.php，监控面板观察新增的COOKIE数据如下：

![22](\images\two\img_d14\22.jpg)



------

2. 构建code15.php，代码如下：	

```
<?php

echo '<pre>';
print_r($_COOKIE);
echo '</pre>';

?>
<script type="text/javascript">
alert(document.cookie);
</script>
```

访问code15.php，观察效果：

javascript输出内容为：

![23](\images\two\img_d14\23.jpg)





php输出内容为：

![24](\images\two\img_d14\24.jpg)



**==小结==**：如果将httponly属性设置为true,则表示只允许原程序脚本代码访问这条COOKIE数据。



------



### 5.3.5 局限

1）COOKIE数据保存在浏览器端（用户机器上），不可控因素高，安全性相对低。

2）每次请求都会携带所有的COOKIE数据，如果数据量大，将占用大量的带宽，降低网站加在效率。



正因以上局限性，SESSION技术应运而生！





## 5.4 SESSION技术

**概念**：将数据持久化存储在**服务器端**，并且是数据能够**区分不同的浏览器**的一种技术。



### 5.4.1 基本操作

对SESSION数据的基本操作包括：设置操作（**增删改**）和查询操作。



**==需求==**：分别实现增、删、改、查SESSION数据的操作，要求

1. 访问code16.php文件，实现新增一条SESSION数据，名为：name，值为：zhangsan；
2. 访问code17.php文件，实现修改"1"中新增的SESSION数据，新值为：lisi；
3. 访问code18.php文件，实现删除SESSION数据name；
4. 以上操作实现完成后，都通过访问code19.php文件来进行查看操作；

**==解答==**：

0. 构建名为code19.php的程序文件，本文件中实现只输出SESSION数据操作，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();
#查询SESSION数据的操作
var_dump( $_SESSION ); 
```

1. 构建名为code16.php程序文件，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();
#新增SESSION数据
$_SESSION['name'] = 'zhangsan';
```

先访问code16.php，然后再访问code19.php，输出内容效果如下：

![25](\images\two\img_d14\25.jpg)



------

2. 构建名为code17.php的程序文件，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();

#修改SESSION数据    下标不变，值改变   
$_SESSION['name'] = 'lisi';
```

先访问code17.php，然后再访问code19.php，输出内容效果如下：

![26](\images\two\img_d14\26.jpg)



------

3. 构建名为code18.php的程序文件，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();

#删除SESSION数据  使用unset删除数组元素一样删除即可
unset($_SESSION['name']);
```

先访问code18.php，然后再访问code19.php，输出内容效果如下：

![27](\images\two\img_d14\27.jpg)

**==小结==**：

1. 对SESSION数据做任何操作之前，**都必须先开启SESSION机制**，我们可以使用**session_start**函数来开启；
2. 对SESSION数据的增删改操作只需要像对**数组**做**增删改**操作一样操作$_SESSION变量即可；
3. 对SESSION数据的**查询操作**，只需要直接像**查询数组元素的值**一样操作$_SESSION变量即可；



------

### 5.4.2 基本原理

**==原理图==**：

![29](\images\two\img_d14\29.png)



**==小结==**：

1. SESSION数据时存储在**服务器**的；
2. SESSION技术的实现本质上需要**依赖于COOKIE技术**；





------

### 5.4.3 $_SESSION和SESSION的关系

**==关系图==**：

![30](\images\two\img_d14\30.png)



**==小结==**：

1. 当session_start时，如果是**首次请求**，则将先去**开辟一个会话数据区空间**，然后将$_SESSION变量**初始化**为**空数组**；如果不是首次请求，则找到之前开辟过得会话数据区，将数据区中的所有数据**取出来**初始化给**$\_SESSION**作为$\_SESSION的数组元素来存在；
2. 当程序运行结束时，PHP会把$_SESSION中的所有数据全部一次性**覆盖**写入SESSION会话数据区；
3. 程序执行的过程中，如果**直接操作到$_SESSION变量**，是**不会**直接操作到SESSION数据区；





------

### 5.4.4 销毁SESSION数据(区)

涉及的函数：

> session_destroy()    销毁SESSION会话数据（区）



**==需求==**：分别实现如下操作

1. 访问code22.php文件，实现新增2条SESSION数据，第一条名为：name，值为：zhangsan；第二条名为：age，值为12；
2. 访问code23.php文件，先打印出所有的SESSION数据，然后再执行销毁SESSION数据区的操作，接着再次打印所有的SESSION数据；
3. 访问code24.php文件，打印出所有的SESSION数据；

**==解答==**：

1. 构建名为code22.php的程序文件，代码如下：

```PHP
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();
$_SESSION['name'] = 'zhangsan';
$_SESSION['age'] = 12;
```

访问code22.php，然后再构建名为code23.php的程序文件，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();
print_r( $_SESSION ); echo '<hr/>';

//销毁SESSION数据区
session_destroy();
print_r( $_SESSION );
```

访问code23.php后，输出的内容为：

![28](\images\two\img_d14\28.jpg)



------

2. 构建code24.php的程序文件，代码如下：

```php
<?php
//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();
print_r( $_SESSION ); echo '<hr/>';
```

访问code24.php，输出的内容如下：

![31](\images\two\img_d14\31.png)



**==小结==**：session_destory**只**负责销毁**SESSION数据区**，其他事情一律不管。





------

### 5.4.5 属性控制

SESSION技术的实现，本质上是**依赖于COOKIE技术**的，在做SESSION操作的时候，**PHP**会自动生成一个名为**PHPSESSID**的**COOKIE数据**。

既然PHPSESSID是一条COOKIE数据，那么，COOKIE数据所具有的属性PHPSESSID也同样拥有。但是，因为PHPSESSID不是我们通过setcookie函数来新增的，而是PHP帮我们增加的，所以，如果我们要控制PHPSESSID这条特殊的COOKIE数据的属性的话，就必须通过配置php.ini相应的配置项来控制。

#### 1) 有效期

和普通的COOKIE数据**相同**

默认情况下也是一个会话周期

一个会话周期表示生成这个COOKIE数据开始到浏览器关闭为止。

#### 2) 有效路径

和普通的COOKIE数据**不同**

默认情况下是网站的**根目录**及**其子目录**下都有效

#### 3) 有效域

和普通的COOKIE数据**相同**

都是当前域名及其子域名下有效。

#### 4) 是否安全传输

和普通的COOKIE数据**相同**

默认情况为http和https都能使用。

#### 5) httponly属性

这个属性对于SESSION无意义。

#### 6) 在php.ini中属性

![2](\images\two\img_d14\2.png)

![3](\images\two\img_d14\3.png)



### 5.5.6 属性设置

涉及函数

> session_set_cookie_params(有效期[,  有效路径[,  有效域[,  是否安全传输[,  httponly]]]])

**==案例==**：通过session_set_cookie_params设定有效期，观察效果。

**==实现==**：构建名为code25.php的程序文件，代码如下：

```php
<?php
//设置PHPSESSID的属性   设置属性必须在session_start之前
session_set_cookie_params(5, '/', 'home.com');

//开启SESSION机制  操作SESSION之前，必须先开启SESSION机制
session_start();

$_SESSION['name'] = 'zhangsan';
```

访问code25.php观察有效期效果：

![32](\images\two\img_d14\32.png)

有效期5秒后，再刷新监控面板，

![33](\images\two\img_d14\33.png)



**==小结==**：

1. session_set_cookie_params必须在开启SESSION机制之前进行设置。





------

### 5.5.7 垃圾回收机制

PHP中存在一种针对SESSION会话数据区的垃圾回收机制，如果PHP发现，在一定的时间内**某个SESSION会话数据区没有被使用**，则在下一次访问时，将会**自动**以**一定的概率清除**这个被认为是无效的垃圾SESSION会话数据区。



涉及到php.ini中的几个配置项：

![34](\images\two\img_d14\34.png)

![35](\images\two\img_d14\35.png)

![36](\images\two\img_d14\36.png)



PHP对于SESSION数据区是否是一个垃圾数据区的判定方法是：如果发现在session.gc_maxlifetime秒数内，如果还没有任何程序访问这个数据区，则会认为这数据区==**可能**==是一个垃圾数据区；接着会以session.gc_probability除以session.gc_divisor得到的概率来进行清除；



**==小结==**：

1. SESSION的垃圾回收机制其实就按照配置文件中指定的配置项，所计算出来概率去清除的。







------

# 6. GD图像处理技术

## 6.1 概念

### 6.1.1why使用

在WEB项目中，GD图像处理技术非常广泛，比如验证码图片，给图片打水印等。



### 6.1.2 what

GD图像处理技术 即PHP通过使用**GD扩展**来操作图像的一种技术。



## 6.2 开启GD扩展

扩展，意味着GD并不是PHP默认就是配置开启的，而是需要额外进行配置的。



**==开启步骤==**：

第一步，打开php.ini查看extension_dir是否正确配置，

![1](\images\two\img_d15\1.jpg)

第二步，开启gd扩展的配置项，

![2](\images\two\img_d15\2.jpg)

检查php_gd2.dll文件是否存在，![3](\images\two\img_d15\3.jpg)

第三步，重启apache，检查gd扩展是否开启成功

![11](\images\two\img_d15\11.png)





## 6.3 GD扩展操作

### 6.3.1 操作分析

在程序中使用GD扩展操作图像，其实就相当于我们在电脑中使用各种绘图软件来绘制图像，比如PS软件。



我们以PS软件绘制图像的方式为切入点，来分析绘图过程中所需要的一些操作有哪些：

1. 打开PS软件  (相当于打开GD扩展)；

2. 创建画布；
3. 在画布做各种操作；
4. 保存图像；
5. 关闭软件；



### 6.3.2 创建画布相关操作

涉及的函数：

> **imagecreate**(宽，高)                                创建画布
>
> **imagecreatetruecolor**(宽,高)                 创建一个真彩色画布
>
> **imagecreatefromjpeg**(jpeg图片路径)   根据一张已有的jpeg图片创建画布
>
> **imagecreatefromgif**(gif图片路径)         根据一张已有的gif图片创建画布
>
> **imagecreatefrompng**(png图片路径)    根据一张已有的png图片创建画布



**==需求==**：根据以下要求完成操作，

1. 根据imagecreate和imagecreatetruecolor两个函数分别创建一个400*200的画布，打印返回值；
2. 根据一张已有的jpeg图片创建画布，打印返回值；

**==解答==**：创建名为code2.php的程序文件，代码如下：

```php
<?php 
	#imagecreate函数
	$img1 = imagecreate(400, 200);
	var_dump($img1);echo "<hr>";

	#imagecreatetruecolor函数
	$img2 = imagecreatetruecolor(400, 200);
	var_dump($img2);echo "<hr>";

	#imagecreatefromjpeg函数
	$img3 = imagecreatefromjpeg('./source/m1.jpg');
	var_dump($img3);echo "<hr>";
```

访问code2.php，输出的内容如下：

![7](\images\two\img_d15\7.jpg)

**小结：**使用创建画布函数得到的结果统一都是资源类型的结果



### 6.3.3 关闭画布操作

涉及的函数：

> **imagedestroy**(画布资源)    销毁画布资源



**==需求==**：根据以下要求完成操作，

1. 根据imagecreate创建一个400*200的画布，打印返回值；
2. 使用imagedestroy关闭打开的画布，再次打印"1"中创建的画布资源返回值；

**==解答==**：创建名为code3.php的程序文件，代码如下：

```php
<?php

#imagecreate函数
$img = imagecreate(400, 200);//单位是像素
var_dump( $img ); echo '<hr/>';

#imagedestroy函数
imagedestroy($img);

var_dump( $img ); 
```

访问code3.php，输出的内容如下：

![4](\images\two\img_d15\4.jpg)





### 6.3.4 图像输出相关操作

涉及函数：

> **imagejpeg()** 以jpeg的格式输出图片到浏览器或保存成文件
>
> **imagepng()** 以png的格式输出图片到浏览器或保存成文件
>
> **imagegif()** 以gif的格式输出图片到浏览器或保存成文件



**==需求==**：创建code4.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 同时实现根据GET方式传递的type值判定，如果type值为1，则直接将"1"中创建的画布以jpeg图片的格式输出到浏览器；如果type值为2，则将"1"中创建的画布以jpeg格式保存成图片文件；

**==解答==**：创建名为code4.php的程序文件，代码如下：

```php
<?php
$type = isset($_GET['type']) ? $_GET['type'] : 1;

#imagecreate函数
$img = imagecreate(400, 200);//单位是像素
//var_dump( $img ); echo '<hr/>';


if( $type==1 ){//表示直接将图像输出到浏览器

    header('Content-type:image/jpeg');//告诉浏览器之后要以image/jpeg的内容类型来对待响应给你浏览器的内容
    imagejpeg($img);

}elseif( $type==2 ){//表示将图像以jpeg格式的图片文件保存下来

    imagejpeg($img, './imgxxx.jpg');
}
```





### 6.3.5 画布内容相关操作

涉及的函数：

> **imagecolorallocate**(画布资源,  R色值,  G色值,  B色值)    分配一个颜色
>
> **imagefill**(画布资源,  基点x坐标,  基点y坐标,  颜色)    向画布填充颜色
>
> **imageline**(画布资源,  起点x坐标,  起点y坐标,  终点x坐标,  终点y坐标,  颜色)    画线段操作
>
> **imagerectangle**(画布资源,  对角线起点x坐标,  对角线起点y坐标,  对角线终点x坐标,  对角线终点y坐标,  颜色)    画矩形
>
> **imagearc**(画布资源,  圆心x坐标,  圆心y坐标,  椭圆宽,  椭圆高,  起点角度,  终点角度,  颜色)    画圆弧线段
>
> **imagestring**(画布资源,  字体大小,  文字左上角x坐标,  文字左上角y坐标,  内容,  颜色)    根据系统字体写字
>
> **imagettftext**(画布资源,  字体大小,  角度,  文字左下角x坐标,  文字左下角y坐标,  颜色,  字体路径,  内容)    根据ttf格式的字体写字



**==需求1==**：创建code5.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答1==**：创建名为code5.php的程序文件，代码如下：

```php
<?php

#imagecreate函数
$img = imagecreate(400, 200);//单位是像素

#分配一个颜色
$color = imagecolorallocate($img, 255, 233, 85);

#填充背景色
imagefill($img, 0, 0, $color);


#将图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($img);
```

访问code5.php，效果为：

![5](\images\two\img_d15\5.jpg)



**==需求1小结==**：

函数：

![1](\images\two\img_d15\1.png)

原理：

![13](\images\two\img_d15\13.png)

以当前选择的坐标基点向四周扩散填充。





**==需求2==**：创建code6.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 在画布上画一条线段；
4. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答2==**：创建名为code6.php的程序文件，代码如下：

```php
<?php
#imagecreate函数
$img = imagecreate(400, 200);//单位是像素
#分配一个颜色
$color = imagecolorallocate($img, 255, 233, 85);
#填充背景色
imagefill($img, 0, 0, $color);
#画线段
$color = imagecolorallocate($img, 0, 12, 214);
imageline($img, 100, 50, 300, 150, $color);

#将图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($img);
```

访问code6.php，效果为：

![15](\images\two\img_d15\15.jpg)

**==需求2小结==**：

函数：

![2](\images\two\img_d15\2.png)

原理：

![14](\images\two\img_d15\14.jpg)



**==需求3==**：创建code7.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 在画布上画一个矩形；
4. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答3==**：创建名为code7.php的程序文件，代码如下：

```php
<?php
#imagecreate函数
$img = imagecreate(400, 200);//单位是像素
#分配一个颜色
$color = imagecolorallocate($img, 255, 233, 85);
#填充背景色
imagefill($img, 0, 0, $color);
#画矩形
$color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));
imagerectangle($img, 120, 90, 300, 150, $color);

#将图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($img);
```

访问code7.php，效果为：

![6](\images\two\img_d15\6.jpg)

**==需求3小结==**：

函数：

![3](\images\two\img_d15\3.png)

原理：对角线两点坐标

!16](\images\two\img_d15\16.png)



**==需求4==**：创建code8.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 在画布上画一个椭圆；
4. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答4==**：创建名为code8.php的程序文件，代码如下：

```php
<?php

#imagecreate函数
$img = imagecreate(400, 200);//单位是像素

#分配一个颜色
$color = imagecolorallocate($img, 255, 233, 85);

#填充背景色
imagefill($img, 0, 0, $color);

#画椭圆
$color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));
imagearc($img, 200, 100, 200, 80, 0, 360, $color);


#将图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($img);
```

访问code8.php，效果为：

![16](\images\two\img_d15\16.jpg)

**==需求4小结==**：

函数：

![4](\images\two\img_d15\4.png)

原理：

![18](\images\two\img_d15\18.png)



**==需求5==**：创建code9.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 在画布上使用imagestring写一句话："today is a goods day"；
4. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答5==**：创建名为code9.php的程序文件，代码如下：

```php
<?php
#imagecreate函数
$img = imagecreate(400, 200);//单位是像素
#分配一个颜色
$color = imagecolorallocate($img, 255, 233, 85);
#填充背景色
imagefill($img, 0, 0, $color);
#使用imagestring写字
//$str = '今天天气好晴朗哟';
$str = 'today is a goods day';
$color = imagecolorallocate($img, mt_rand(0, 255), mt_rand(0, 255), mt_rand(0, 255));
imagestring($img, 5, 100, 80, $str, $color);
#将图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($img);
```

访问code9.php，效果为：

![20](\images\two\img_d15\20.png)

**==需求5小结==**：

函数：

![5](\images\two\img_d15\5.png)







**==需求6==**：创建code10.php程序文件，

1. 使用imagecreate创建一个400*200的画布；
2. 将画布的背景色填充为RGB(255, 233, 85)；
3. 在画布上使用imagettftext写一句话："今天天气好晴朗"；
4. 将画布以jpeg格式的图片直接输出到浏览器；

**==解答6==**：创建名为code10.php的程序文件，代码如下：

```php
<?php 
	$img = imagecreate(400,200);

	$color = imagecolorallocate($img, 255, 233, 85);

	imagefill($img, 0, 0, $color);

	$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));

	$str ='今天天气好晴朗';
	imagettftext($img, 30, 0, 70,150, $color, 'D:/PHP/code php/xjrybxk.ttf',$str);

	header('Content-type:image/jpeg');
	imagejpeg($img);
 ?>
```

访问code10.php，效果为：

![17](\images\two\img_d15\17.jpg)

**==需求6小结==**：

函数：

![6](\images\two\img_d15\6.png)

原理：1）角度是逆时针旋转的。2）ttf字体文件的路径在php7.x的版本后需要指定成从盘符开始的绝对路径地址。



### 6.3.6辅助相关操作

涉及的函数：

> ==**imagesx**==(画布资源)    获得图片的宽度
>
> **==imagesy==**(画布资源)    获得图片的高度
>
> **getimagesize**(图片路径)    获得图片的宽度和高度等信息



**==需求==**：创建code11.php程序文件，

1. 使用imagecreatefromjpeg创建一个画布；
2. 获取这个画布的宽度；
3. 获取这个画布的高度；
4. 获取这个画布的宽度、高度、位度等信息；

**==解答==**：创建名为code11.php的程序文件，代码如下：

```php

```

访问code11.php，效果为：

![22](\images\two\img_d15\22.png)





## 6.4 案例：制作水印图

### 6.4.1 功能分析

1. 基于需要打水印的图片（目标图片）创建一个画布；
2. 基于水印图创建一个画布；
3. 在目标图片中选择一个坐标基点；
4. 在水印图片上选择一个坐标基点（（0，0）点）；
5. 将水印图拖拽进目标图，让两张图片的坐标基点对其重合;
6. 调整在目标图片中水印图的透明度；
7. 将打好水印的成品图保存成jpg文件；
8. 关闭目标画布，关闭水印图画布；



涉及的函数：

> **imagecopymerge(）**           拷贝并合并图像的一部分



### 6.4.2 代码实现

```php
<?php

#1. 基于需要打水印的图片（目标图片）创建一个画布
$dst = imagecreatefromjpeg('./source/m1.jpg');

#2. 基于水印图创建一个画布
$src = imagecreatefrompng('./source/logo.png');

$src_w = imagesx($src);//水印图的宽度
$src_h = imagesy($src);//水印图的高度

#第3～6步，需要通过imagecopymerge函数来实现
imagecopymerge($dst, $src, 300, 100, 0, 0, $src_w, $src_h, 15);

#7. 将目标图像输出到浏览器
header('Content-type:image/jpeg');
imagejpeg($dst_img);

#8. 关闭画布资源
imagedestroy($dst);
imagedestroy($src);
```

访问后的效果：

![18](\images\two\img_d15\18.jpg)



## 6.5 案例：制作缩略图

### 6.5.1 固定宽高缩略图

#### 1） 功能分析

1. 根据一张需要缩小的图片（西瓜头）创建画布；
2. 创建一个300*200px的空白画布（目标画布）；
3. 在目标画布上选择左上角(0,0)点作为坐标基点；
4. 在西瓜头画布上选择左上角(0,0)点作为坐标基点；
5. 将西瓜头画布拖拽进目标画布中，并且让西瓜头画布的坐标基点对其目标画布的坐标基点；
6. 将西瓜头画布的宽度调整为与目标图画布宽度相等的宽度；
7. 将西瓜头画布的高度就调整为与目标图画布高度相等的高度；
8. 将目标图保存成jpg格式的图片；
9. 关闭西瓜头画布，关闭目标图画布；

#### 2）代码实现

创建名为code13.php的程序文件，代码如下：

```php
<?php
#1. 根据一张需要缩小的图片创建画布
$src = imagecreatefromjpeg('./source/m2.jpg');
$src_w = imagesx($src);//获得画布的宽度
$src_h = imagesy($src);//获得画布的高度

#2. 创建一个300*200px的空白画布（目标画布）
//$dst = imagecreate(300, 200);
$dst = imagecreatetruecolor(400,200);

#第3～7步，需要imagecopyresampled来实现缩略图
imagecopyresampled($dst, $src, 0, 0, 0, 0, 400,200, $src_w, $src_h);

#8. 输出目标图像到浏览器
header('Content-type:image/jpeg');
imagejpeg($dst);

#9. 关闭画布资源
imagedestroy($src);
imagedestroy($dst);
```

访问后的效果：

![19](\images\two\img_d15\19.jpg)



固定宽高的缩略图，其实是没有考虑到原图的宽高比例的，实际缩小以后，很可能会变形。



### 6.5.2 等比缩略图

创建名为code14.php的程序文件，代码如下：

```php
<?php
$max_w = 500;//限定最终缩略图最大的宽度不能超过200px
$max_h = 300;//限定最终缩略图最大的高度不能超过300px


#1. 根据一张需要缩小的图片（西瓜头）创建画布
$src = imagecreatefromjpeg('./source/m2.jpg');

$src_w = imagesx($src);//获得西瓜头画布的宽度
$src_h = imagesy($src);//获得西瓜头画布的高度

#计算缩略图的宽度和高度
$dst_h = $max_h;//先将高度缩小到限定区域的高度
/*
原图的宽度/原图的高度=缩略图的宽度/缩略图的高度
缩略图的宽度=(原图的宽度/原图的高度)*缩略图的高度
*/
$dst_w = ($src_w/$src_h)*$dst_h;//计算得到缩略图的宽度

if( $dst_w>$max_w ){//如果计算得到的缩略图的宽度比限定区域的宽度还要大，则重新计算缩略图的宽度和高度

    $dst_w = $max_w;//先将宽度缩小到限定区域的宽度
    /*
原图的宽度/原图的高度=缩略图的宽度/缩略图的高度
缩略图的高度=缩略图的宽度/(原图的宽度/原图的高度)
    */
    $dst_h = $dst_w/($src_w/$src_h);
}


#2. 创建一个300*200px的空白画布（目标画布）
$dst = imagecreatetruecolor($dst_w, $dst_h);

#第3～7步，需要imagecopyresampled来实现缩略图
imagecopyresampled($dst, $src, 0, 0, 0, 0, $dst_w, $dst_h, $src_w, $src_h);

#8. 输出目标图像到浏览器
header('Content-type:image/jpeg');
imagejpeg($dst);

#9. 关闭画布资源
imagedestroy($src);
imagedestroy($dst);
```

访问后的效果：

![20](\images\two\img_d15\20.jpg)



## 6.6 案例：制作验证码

### 6.6.1 功能分析

1. 创建画布，填充背景色；
2. 写字；
3. 构建干扰元素；



### 6.6.2 代码实现

创建名为code15.php的程序文件，代码如下：

```php
<?php 
	//1. 创建一个画布
	$img = imagecreatetruecolor(300, 150);
	$i_h = imagesy($img);//画布的高
	$i_w = imagesx($img);//画布的宽


	//2. 背景色
	$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));
	//填充颜色
	imagefill($img, 0, 0, $color);
	
	//3. 创建字符
	$str = '';
	for ($i=0; $i <4; $i++) { 
		//添加字符
		$num_arr = array_merge(range(0, 9),range('a', 'z'),range('A', 'Z'));

	$num = ($num_arr[rand(0,61)]);
		$str .=$num; 
	}
	
	
	//4. 写字
	$h = rand($i_h*(1/3),$i_h*(3/4));
	$w = rand($i_w*(1/4),$i_w*(1/3));


	$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));
	
	imagettftext($img, 70, 0, $h, $w, $color,'D:/PHP/code php/xjrybxk.ttf',$str);


	//5. 制作干扰
	//5.1 画点
	for ($i=0; $i < 100; $i++) { 
		$h = rand(0,$i_h);
		$w = rand(0,$i_w);
		
		$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));
		imageline($img, $w, $h,rand($w-2,$w+2) ,rand($h-2,$h+2), $color);
	}

	//5.2 画线
	for ($i=0; $i < 20; $i++) { 
		$h = rand(0,$i_h);
		$w = rand(0,$i_w*(1/2));
		
		$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));

		imageline($img, $w, $h,rand($w,$i_w) ,rand(0,$i_h), $color);
	}
	
	//5.3画曲线
	for ($i=0; $i < 10; $i++) { 
		$h = rand($i_h*(1/3),$i_h*(3/4));//圆心y坐标
		$w = rand($i_w*(1/3),$i_w*(3/4));//圆心x坐标
		
		$color = imagecolorallocate($img, mt_rand(0,255), mt_rand(0,255), mt_rand(0,255));

		imagearc($img, $w, $h, rand(0,$i_w*(1/2)), rand(0,$i_h*(1/2)), rand(0,120), rand(90,180), $color);
	}

	//输出画布
	header('Content-type:image/jpeg');
	imagejpeg($img);
 ?>
```

效果：

![21](\images\two\img_d15\21.jpg)