---
title: php基础
date: 2019-01-09 14:02:32
categories: 
          - php
tags:
    - php
notshow: true
---


# PHP基础
<!-- more -->

## 1. PHP语法初步

### 1.1 PHP代码标记

------

#### 1.1.1 最常用的PHP标记

开始标记语法：**<?php**

结束标记语法：**?>**

**==演示案例==：**

![4](\images\two\img_d2\4.png)



#### 1.1.2 短标记short_open_tag型

开始标记：**<?**

结束标记：**?>**

**使用条件**：必须在php.ini中开启短标记语法的配置项short_open_tag

**==演示案例==**：

1. 首先打开PHP的配置文件php.ini，将short_open_tag配置项修改为On值，

   ![5](\images\two\img_d2\5.png)

2. 然后再重启apache，构建测试代码进行访问，

   ![6](\images\two\img_d2\6.png)

   测试代码为：

   ![7](\images\two\img_d2\7.png)

   访问code2.php，效果为：

   ![8](\images\two\img_d2\8.png)



#### 1.1.3 PHP标记的简便使用方式

如果程序脚本中==最后一行后面==已经==没有任何程序代码==了（包括html代码），则结束标记可以==省略==不写。

**==演示案例==**：

![9](\images\two\img_d2\9.png)

------

### 1.2 PHP中的注释

**作用**：被注释的内容将不会被解析执行，是方便程序人员在程序中记录信息说明的一种方式。

PHP中的注释主要包括**两类**：1）行注释(两种)；2）块注释；



#### 1.2.1 行注释

第一种行注释语法：==**//**==

第二种行注释语法：==**#**==

**==演示案例==**：

![10](\images\two\img_d2\10.png)



#### 1.2.2 块注释

开始块注释标记：==**/***==

结束块注释标记：==***/**==

**==演示案例==**：

![11](\images\two\img_d2\11.png)

------

### 1.3 PHP中的语句分隔符（结束符）

符号：**;**   (英文半角分号)

意义：用来表示一句PHP语句的结束，通常没有指定将会报错。

**==演示案例==**：

![12](\images\two\img_d2\12.png)

**小结**：虽然在上面这个演示案例中有存在特殊的情况可以不写语句结束符，但是以后在书写代码时，最好养成良好的习惯，每句PHP语句写完都加上语句结束符";"。



------







## 2. 变量

**概念**： 变量就是**临时**保存数据的载体。

变量的**特点**：在PHP程序执行结束后，程序中的所有变量将会被自动销毁。

定义语法：**$变量名=变量值;**

**==演示案例==**：

![13](\images\two\img_d2\13.png)

### 2.1 变量名的命名规则

**规则**： 只能是由字母、数字、下划线组成的字符，并且不能以数字开头。!15](\images\two\img_d2\15.png)

**==演示案例==**：

![14](\images\two\img_d2\14.png)



### 2.2 变量的基本使用

#### 2.2.1 设置操作（增删改）

**==演示案例==**：

![15](\images\two\img_d2\15.png)



#### 2.2.2 查询操作

![16](\images\two\img_d2\16.png)

#### 2.2.3 赋值的概念

在PHP中，通过等号“=====”将一个值给到另外一个变量的过程，被称为“赋值”。

**==演示案例==**：

![17](\images\two\img_d2\17.png)



### 2.3 PHP代码嵌入HTML中的注释问题

**需求1**：实现将PHP代码嵌入HTML代码中，查看效果。

**解答1**：

![18](\images\two\img_d2\18.png)

**需求2**：实现将PHP代码嵌入HTML代码中的注释中，查看效果。

**解答2**：

![19](\images\two\img_d2\19.png)

**==tips==**：通过以上两个例子，我们了解到：

1. PHP的代码是可以被嵌入HTML内容中的；
2. PHP的内容即便嵌入HTML的注释中，也一样会被解析执行，HTML的注释是控制不住PHP的内容；

![20](\images\two\img_d2\20.png)



### 2.4 预定义变量

PHP中的预定义变量包括：1）**九大超全局预定义数组变量**；2）其他预定义变量 



#### 2.4.1 九大超全局预定义数组变量

包括以下九个成员：

> **$_ENV**                           **$_SERVER**
>
> ​			以下三个将会在表单传值部分进行讲解
>
> **$_GET**                            **$_POST**                              **$_REQUEST**
>
> ​			以下两个将会在会话技术部分进行将爱那个接
>
> **$_COOKIE**                     **$_SESSION**
>
> ​			下面这个将会在文件上传部分进行讲解
>
> **$_FILES**
>
> ​			下面这个将会在作用域部分进行讲解
>
> **$GLOBALS**

| 九大超全局预定义数组变量 | 用法                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **$_ENV**                | 获得程序所部署的环境相关信息。                               |
| **$_SERVER**             | 服务器和执行环境信息                                         |
| **$_GET**                | $_GET 被广泛应用于收集表单数据，在HTML form标签的指定该属性："method="get"。 |
| **$_POST**               | $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性："method="post"。 |
| **$_REQUEST**            | 用于收集HTML表单提交的数据。                                 |
| **$_COOKIE**             | $_COOKIE 变量用于取回 cookie 的值。                          |
| **$_SESSION**            | 存储和取回 session 变量                                      |
| **$_FILES**              | 通过使用 $_FILES，可以从客户计算机向远程服务器上传文件。     |
| **$GLOBALS**             | 引用全局作用域中可用的全部变量                               |

**1) $_ENV**

作用：获得程序所部署的环境相关信息。

==直接输出==该变量==将无法获取任何信息==，需要先配置php.ini中的variables_order选项才能查看。

**==演示案例==**：

1. 打开php的配置文件php.ini，在variables_order选项中加上E，开启$_ENV的值，

   ![21](\images\two\img_d2\21.png)

2. 访问输出$_ENV的程序文件，查看效果：

   ![22](\images\two\img_d2\22.png)



**2) $_SERVER**

作用：获得与服务器交互的相关信息。

**==演示案例==**：

![23](\images\two\img_d2\23.png)



#### 2.4.2 其他预定义变量

**3) $argv和$argc变量**

**注意**：这两个变量也是PHP实现预定义好了的，但是如果通过浏览器直接访问程序，是无法会的任何的信息的。

![24](\images\two\img_d2\24.png)

**==演示案例==**：

![25](\images\two\img_d2\25.png)

**==小结==**：通过上面这个演示案例，我们观察到：

$argv包含的是  执行程序文件时，传递给这个程序文件的 **参数数据**，$argv的第一条数据永远都是这个被执行的程序文件的全路径；

$argc包含的是  $argv的数据  个数；





### 2.5 可变变量

**概念**：某个变量的变量名被另外一个变量的变量值所代替，这个变量就叫可变变量。 

**==演示案例==**：

![26](\images\two\img_d2\26.png)



### 2.6 变量的传值

变量的传值包括==两个部分==： 1）变量的值传递；2）变量的引用传递；

####  2.6.1 变量的值传递

**==演示案例==**：

![27](\images\two\img_d2\27.png)

**变量值传递的原理**：

![28](\images\two\img_d2\28.png)

**小结**：所谓的变量值传递，指的是修改其中一个变量的值，并不影响另外一个变量的值。



#### 2.6.2变量的引用传递

**==演示案例==**：

![29](\images\two\img_d2\29.png)

变量引用传递的原理：

![30](\images\two\img_d2\30.png)

**小结**：所谓的变量引用传递，就是修改其中一个变量的值，另外一个变量也将会受到影响。



------



## 3. 常量

**概念**：常量也是程序中保存数据的载体，但是在**整个程序脚本执行过程中只能定义一次**。 



### 3.1 常量的定义语法

包括两种：1）通过==const==关键字定义；2）通过==define==函数进行定义；

**==演示案例==**：

![31](\images\two\img_d2\31.png)

**需求1**：在程序中同时定义两个同名的常量，查看效果。

**解答1**：

![32](\images\two\img_d2\32.png)

**需求2**：在程序中定义一个常量，然后再次通过赋值的方式为常量赋值，查看效果。

**解答2**：

![33](\images\two\img_d2\33.png)

**==小结==**：

1. 常量在程序中只能定义一次，之后就不能进行修改了。

   

### 3.2 数组常量

在php7之后，常量支持以数组的形式来进行定义。 

**注意**：该知识点有点超前，目前大家只需了解PHP7之后常量支持以数组的形式来进行定义即可。

**==演示案例==**：

![34](\images\two\img_d2\34.png)

### 3.3 常量的使用

分别完成如下需求操作：

**需求1**：在程序中定义一个常量，并且输出该常量的值，查看效果。

**解答1**：

![35](\images\two\img_d2\35.png)

**需求2**：在程序中定义一个包含特殊字符的常量，并且尝试输出该常量的值，查看效果。

**解答2=**：

![36](\images\two\img_d2\36.png)

**小结**：

1. 如果常量名不包含特殊字符，则只需要像输出变量一样去输出常量即可；
2. 如果常量名包含该特殊字符，则需要使用PHP的内置函数constant来进行输出；



#### 3.3.1 判断一个常量是否存在

操作方法：通过defined==函数==来进行判断常量是否存在。

**==演示案例==**：

![37](\images\two\img_d2\37.png)

#### 3.3.2 获得程序中定义出来的所有常量操作

操作方法：需要通过get_defined_constants==函数==获得当前程序脚本中所有的常量。

**==演示案例==**：

![38](\images\two\img_d2\38.png)

### 3.4 系统常量（预定义常量）

所谓的系统常量，其实就是PHP事先帮我们定义好的一些常量。

手册中的位置： 

![1](\images\two\img_d2\1.png)

**==演示案例==**：

![39](\images\two\img_d2\39.png)

**==小结==**：所谓的系统常量，指的是PHP帮我们预先定义好的常量。



### 3.5 魔术常量

| 名称                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| **\_\_LINE\_\_**      | 文件中的当前行号。                                           |
| **\_\_FILE\_\_**      | 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 |
| **\_\_DIR\_\_**       | 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 |
| **\_\_FUNCTION\_\_**  | 函数名称                                                     |
| **\_\_CLASS\_\_**     | 类的名称                                                     |
| **\_\_TRAIT\_\_**     | Trait 的名字                                                 |
| **\_\_METHOD\_\_**    | 类的方法名                                                   |
| **\_\_NAMESPACE\_\_** | 当前命名空间的名称（区分大小写）。                           |

魔术常量本质上==不能算==是严格意义上的==常量==，常量在脚本代码中是不允许被修改的，也就是值是固定的，但是魔术常量会随着在脚本代码中位置的变换，其值也会发生改变。

**==演示案例==**： 

![40](\images\two\img_d2\40.png)

**==小结==**：

![41](\images\two\img_d2\41.png)

1. 魔术常量会随着在程序脚本中的位置的变换，其值也会发生改变；
2. 2.\_\_FILE\_\_魔术常量表示的是这个魔术常量所写在的文件的全路径；（它写在哪个文件里，就代表这个文件的全路径） aQ 





## 4. 数据类型

### 4.1 数据类型的分类

PHP中数据类型主要分为**三个大类**： 1）标量数据类型；2）复合数据类型；3）特殊数据类型；

> **标量数据类型**：a）整型（**int**）； b）浮点型（**float**）；c）字符串型（**string**）；d）布尔型（**bool**）；
>
> **复合数据类型**：a）数组（**array**）；b）对象（**object**）；
>
> **特殊数据类型**：a）资源类型（**resource**）；b）NULL类型；
>



------



### 4.2 整型（int）

含义：指的就是数学中的整数。英文全名：intval 

**==演示案例==**：![42](\images\two\img_d2\42.png)

我们通常习惯使用的都是十进制的数值，但是在计算机中，也经常会使用其他进制的整型数值。

#### 4.2.1 八进制整型数字和十六进制整型数字

1) 定义**八进制整型**数字方法：以0（整数零）开头的数字。

**==演示案例==**：

![43](\images\two\img_d2\43.png)



2) 定义**十六进制整型**数字方法：以0x（零+英文x）开头的数字。 

**==演示案例==**：

![44](\images\two\img_d2\44.png)

**小结**：

1. 八进制以0（整数零）开头的数字；十六进制以0x（零+英文x）开头的数字。



#### 4.2.2 整型的最大值和最小值的问题

在PHP中，整型固定是以**4个字节**保存。

| 有符号（最大值/最小值）           | 无符号（最大值/最小值） |
| --------------------------------- | ----------------------- |
| \- 2147483648 / 2147483647        | 0 / 4294967295          |
| 计算方法：-2^(32-1)  / 2^(32-1)-1 | 计算方法：0 / 2^(32)-1  |



#### 4.2.3 进制转换

##### 1) 十进制转N进制（短除法）

转换方法：用十进制数字除以N，余数反向连接。

**需求1**：十进制12转八进制 m

**解答1**：





**需求2**：十进制12转十六进制

**解答2**：



**需求3**：十进制100转十六进制

**解答3**：



##### **2) N进制转十进制**

```mysql
公式：k(m)*N^(m-1)+k(m-1)*N^(m-1-1)+k(m-2)*N^(m-2-1) + …… + k(2)*N^(2-1)+k(1)*N^(1-1);
# 参数说明：
# k(m)表示第m号位置上的数字；
# N表示被转换的那个数字的进制；
# 顺序是从右到左依次递增，最右边是第一号位置。
```

**需求1**：十六进制100转十进制

**解答1**：



**需求2**：八进制100转十进制

**解答2**：



##### 3) 十进制小数转二进制

转换方法：十进制小数乘以2，直到乘尽无小数为止，然后将整数部分顺序连接。

**需求1**：十进制小数0.625转二进制

**解答1**：



**需求2**：十进制小数0.3转二进制

**解答2**：



##### 4) 进制转换相关函数

**bin**：binary二进制          **dec**：decimal十进制          **oct**：octal八进制         **hex**：hexdecimal十六进制

| 函数                    | 作用                                       |
| ----------------------- | ------------------------------------------ |
| **abs**(函数)           | 取一个数值的绝对值                         |
| **bindec**(函数)        | 二进制转十进制                             |
| **octdec**(函数)        | 八进制转十进制                             |
| **hexdec**(函数)        | 十六进制转十进制                           |
| **decbin**(函数)        | 十进制转二进制                             |
| **decoct**(函数)        | 十进制转八进制                             |
| **dechex**(函数)        | 十进制转十六进制                           |
| **base_convert**(函数 ) | n进制转m进制（取值范围是2到36，包括2和36） |

**==演示案例==**：

![52](\images\two\img_d2\52.png)





------

### 4.3 浮点型(float)

含义：相当于数学当中的==小数==，PHP语言默认浮点型就是双精度浮点型，占8个字节。

**==演示案例==**：

![54](\images\two\img_d3\54.png)



#### 4.3.1 浮点型数字比较问题

TIPS：由于浮点型数据在计算机中转换为二进制进行存储时，可能会存在==精度丢失==的问题，故浮点型数据的比较时常会出现不准确的情况。

**==演示案例==**：

![55](\images\two\img_d3\55.png)

**小结**：

在今后的项目中，请尽量规避使用浮点型数据进行比较。



#### 4.3.2 科学计数法来表示浮点型

TIPS：需要使用字母e的结构来进行构建，e后面是负数，代表总共有多少位小数。

**==演示案例==**：

![56](\images\two\img_d3\56.png)



------

### 4.4 布尔型

TIPS：布尔值只有两个值，==true代表真==，==false代表假==。多用于比较之后得到的结果。

**==演示案例==**：

![57](\images\two\img_d3\57.png)



------

### 4.5 字符串型

TIPS：在PHP中，被引号（单引号或双引号都可以）所包裹的内容就是字符串。

**==演示案例==**：

![58](\images\two\img_d3\58.png)

#### 4.5.1 单引号与双引号包裹的区别

TIPS：在PHP中，由单引号与双引号定义的字符串是有区别的。

**==演示案例==**：

![59](\images\two\img_d3\59.png)

**==小结==**：

==如果变量写在了由单引号定义的字符串中，则变量将不会被解析成对应的值；如果变量写在了由双引号定义的字符串中，则变量将会被解析成对应的值。==



#### 4.5.2 更加良好的书写习惯

TIPS：通常，如果双引号中包含了变量，我们会使用"{}"包裹变量。

**==演示案例==**：

![60](\images\two\img_d3\60.png)



------



### 4.6 数组型

==定义==：数组即==键值对==的集合。

数组的==一组键值对==也被称为数组的==一个元素==；数组元素的==键==也被称为数组元素的==下标==。

**==演示案例==**：

![61](\images\two\img_d3\61.png)

#### 4.6.1 数组元素的键

TIPS：数组的元素的键==只会==是==整型或者字符串型==。

**==演示案例==**：

![62](\images\two\img_d3\62.png)

**==小结==**：

虽然在PHP中，定义数组元素的下标，没有硬性规定一定要符合下标的要求来定义，但是我们最好在定义时，按照定义下标的要求来定义。



#### 4.6.2 数组元素的值

TIPS：数组元素的值可以是==任意数据类型==。

**==演示案例==**：

![63](\images\two\img_d3\63.png)



#### 4.6.3 数组的两种定义方式

在PHP中，数组可以使用两种方式进行定义：1）array结构的方式；2）中括号"[]"结构的方式；

##### 1**) array结构**

array结构又包含两种定义方法：1）指定元素下标定义法；2）不指定元素下标定义法

**==演示案例==**：指定元素下标定义法

![64](\images\two\img_d3\64.png)

**==演示案例==**：不指定元素下标定义法

![65](\images\two\img_d3\65.png)



##### 2) 中括号"[]"结构

中括号"[]"结构也包含两种定义方法：1）指定元素下标定义法；2）不指定元素下标定义法

**==演示案例==**：指定元素下标定义法

![66](\images\two\img_d3\66.png)



##### 3) 数组定义方式的总结

有两种定义方式：1)使用array结构的方式；2）使用中括号"[]"结构的方式；

使用array结构：a）指定下标定义法；b）不指定下标定义法；

使用中括号"[]"结构：a）指定下标定义法；b）不指定下标定义法；



#### 4.6.4 数组的调用

数组的调用其实主要就是如何调取到数组元素的值。

![68](\images\two\img_d3\68.png)



------



### 4.7 对象型

TIPS：对象和数组同属于复合数据类型，在PHP中，对象的数据结构和数组的数据结构非常的相似，我们把对象经常称为：有生命力的数组。

**==演示案例==**：使用系统类stdClass创建一个对象。

![69](\images\two\img_d3\69.png)





------



### 4.8 资源型

TIPS：我们当前还没有学到文件相关操作，当前为了能够直观的观察到资源类型的形态，我们前置性的使用fopen函数在程序中打开一个文件。此处，只要求大家对资源类型有一个直观的认识即可。

**==演示案例==**：

![70](\images\two\img_d3\70.png)

**小结**：

资源指的是内存当中的物理空间。



------



### 4.8 NULL

TIPS：NULL类型只有一个数据，就是NULL自己。表示空，即什么都没有的意思。

**==演示案例==**：

![71](\images\two\img_d3\71.png)





------





## 5. 字符串相关函数

涉及的函数：

> 1）转换函数：==implode==(), ==explode==(), str_split()
>
> 2）截取函数：==trim==(), ltrim(), rtrim()
>
> 3）截取函数：==substr==(), strstr()
>
> 4）大小写转换函数：strtolower(), strtoupper(), ucfirst()
>
> 5）查找函数：strpos(), strrpos()
>
> 6）替换函数：==str_replace==()
>
> 7）格式化函数：printf(), sprintf()
>
> 8）常用输出函数：echo(), print_r()，var_dump()
>
> 9）其他：==str_repeat==(), str_shuffle()



------



### 5.1 String函数 （字符串函数）

#### 5.1.1 字符串—数组 转换

| 函数        | 描述                                   |
| ----------- | -------------------------------------- |
| implode()   | 把数组粘合成一个字符串。返回值：字符串 |
| explode()   | 把字符串打散为数组                     |
| str_split() | 把字符串一个个(或自定义)分割到数组中。 |



**implode、explode、str_split函数**

内容如下：

```php
//implode
$arr = ['name'=>'墨子', 'age'=>12, 'height'=>3.1];
$re = implode('&', $arr);//以第一个参数指定的字符，来连接第二个参数指定的数组元素的值，最终得到一个连接后的字符串
echo $re; 
echo '<hr/>';

//explode
$str1 = '韩非子||13||2.1||aa';
$arr1 = explode('||', $str1);//以第一个参数指定的字符，来炸开第二个参数指定的字符串，最终得到一个数组，这个数组的每个元素值都第二个参数炸开后的每一个字符串的值。
print_r( $arr1 ); 
echo '<hr/>';

//str_split
$str2 = 'abcde';
$re = str_split($str2);//如果不指定第二个参数，则str_split将会把第一个参数指定的字符串按照1个长度的字符炸开成一个新的数组
print_r( $re ); echo '<br/>';

$re = str_split($str2, 3);//如果指定了第二个参数，则str_split将会把第一个参数指定的字符串按照第二个参数指定的长度炸开成一个新的数组，如果最后一个数组元素值不足第二个参数指定的长度，则自成最后一个元素值
print_r($re);
```

效果为：

![72](\images\two\img_d3\72.png)



------



#### 5.1.2 除空白函数

| trim()  | 移除字符串两侧的空白字符和其他字符。 |
| ------- | ------------------------------------ |
| 函数    | 描述                                 |
| ltrim() | 移除字符串左侧的空白字符或其他字符。 |
| rtrim() | 移除字符串右侧的空白字符或其他字符。 |



**trim, ltrim, rtrim函数**

内容如下：

```php
//trim
$str1 = "   zhan    gsan  \r\n";
var_dump( $str1 ); echo '<br/>';
$re_str = trim($str1);//去除指定的字符串首尾的空白字符
var_dump( $re_str ); 
echo '<hr/>';

//ltrim
$str1 = "   zhan    gsan  \r\n";
var_dump( $str1 );  echo '<br/>';
$re_str = ltrim($str1);//去除左边的空白字符，右边的不负责处理
var_dump( $re_str ); 
echo '<hr/>';

//rtrim
$str1 = "   zhan    gsan  \r\n";
var_dump( $str1 );  echo '<br/>';
$re_str = rtrim($str1);//去除右边的空白字符，左边的不负责处理
var_dump( $re_str ); 
```

效果为：

![73](\images\two\img_d3\73.png)



------



#### 5.1.3 截取函数

| 函数     | 描述                                                       |
| -------- | ---------------------------------------------------------- |
| substr() | 用于截知道位置 从哪到哪截                                  |
| strstr() | 查找字符串在另一字符串中的第一次出现  false往后截 true往前 |



**substr, strstr函数**

代码内容如下：

```php
//substr
$str1 = 'abcdefgh';

$re = substr($str1, 1);//不指定第三个参数，则表示从第二个参数的位置开始截取，一直截取到第一个参数的最末尾
echo $re;   echo '<br/>';

$re = substr($str1, 1, 3);//指定了第三个参数，则表示从第二个参数的位置开始截取，一直截取第三个参数指定的长度
echo $re;   echo '<br/>';

$re = substr($str1, -5);//如果指定的第二个参数为负数，则表示从最右边往左边截取，截取指定的第二个参数的长度
echo $re; 
echo '<hr/>';


//strstr
$str2 = 'abcdefghdeaaaaaadebbbbbbb';

$re = strstr($str2, 'de');//不指定第三个参数，则表示从第二个参数开始截取，一直截取到第一个参数的最末尾为止；如果第一个参数中包含多个第二个参数值，则从左往右，遇到的第一个值开始截取一直截取到最右边末尾为止。
echo $re; echo '<br/>';

$re = strstr($str2, 'de', true);//如果指定了第三个参数为true，则表示在第一个参数中从左往右找第二个参数首次出现的位置，找到之后然后反向截取到第一个参数的最左边。
echo $re; 
```

效果为：

![74](\images\two\img_d3\74.png)



------



#### 5.1.4 大小写转换函数

| 函数         | 描述                         |
| ------------ | ---------------------------- |
| strtolower() | 把字符串全部转换为小写字母。 |
| strtoupper() | 把字符串全部转换为大写字母。 |
| ucfirst()    | 把字符串中的首字符转换为大写 |

**strtolower, strtoupper, ucfirst函数**

![75](\images\two\img_d3\75.png)



------



#### 5.1.5 查找函数

| 函数      | 描述                                        |
| --------- | ------------------------------------------- |
| strpos()  | 返回字符串第一次出现的位置 。返回位置值     |
| strrpos() | 返回字符串倒数第一次出现的位置 。返回位置值 |

**strpos, strrpos函数**

![76](\images\two\img_d3\76.png)



------



#### 5.1.6 替换函数

| 函数          | 描述                   |
| ------------- | ---------------------- |
| str_replace() | 替换字符串中的一些字符 |



**str_replace函数**

![77](\images\two\img_d3\77.png)



------



#### 5.1.7 格式化函数

| 函数      | 描述                             |
| --------- | -------------------------------- |
| printf()  | 输出格式化的字符串。             |
| sprintf() | 把格式化的字符串写入一个变量中。 |



![78](\images\two\img_d3\78.png)

![79](\images\two\img_d3\79.png)



------



#### 5.1.8 常用输出函数

| 函数       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| echo()     | 只能以字符串的形式输出内容。通常适合输出字符串或整型浮点数据 |
| print_r()  | 适用于除布尔型 资源型 null外其他类型                         |
| var_dump() | 既能输出数据的值，又能够输出数据得知所属的数据类型           |

![80](\images\two\img_d3\80.png)



------



#### 5.1.9 其他

| 函数          | 描述                           |
| ------------- | ------------------------------ |
| str_repeat()  | 把字符串重复指定的次数。       |
| str_shuffle() | 随机地打乱字符串中的所有字符。 |



![81](\images\two\img_d3\81.png)



------





## 6.  字符串转义

转义符号：**==\\==**

TIPS：在PHP定义的字符串中，1）有些字符具有特殊的意义，我们可以通过转义符让这些特殊的字符变成普通的字符；2）有些字符本身不具有特殊的意义，但是我们可以通过转义符让这些普通字符转变为具有特殊意义的字符；



**==演示案例==**：

1）在双引号定义的字符串中输出双引号；

![82](\images\two\img_d3\82.png)



2）在单引号定义的字符串中输出单引号；

![83](\images\two\img_d3\83.png)

3）在双引号定义的字符串中输出$符号；

![84](\images\two\img_d3\84.png)

4）在双引号定义的字符串中输出"\\"符号；

![85](\images\two\img_d3\85.png)

5）在双引号定义的字符串中输出制表符；

![86](\images\two\img_d3\86.png)

6）在双引号定义的字符串中输出回车换行符；

![87](\images\two\img_d3\87.png)



**==小结==**：

转义符可以使特殊的字符变成普通的字符，也可以使某些普通的字符变成特殊的字符。



------



## 7.类型转换

TIPS：在PHP中类型转换包括两种：1）自动类型转换；2）强制类型转换； 



### 7.1 自动类型转换

TIPS：自动类型转换无需我们人为在程序中指定操作，这个转换操作是由PHP在某种特定的情况下自动去完成的。

**==演示案例==**：

1）在运算表达式中存在多种数据类型时；![88](\images\two\img_d3\88.png)

2）实际指定的数据类型与规定的数据类型不一致时；

![89](\images\two\img_d3\89.png)

**==小结==**：

自动类型转换无需我们手动操作，当满足一定的条件时，PHP会自动进行转换处理。



------



### 7.2 强制类型转换

#### 7.2.1 转换方法：括号转换。

> （int）、（integer）：转换成整形
>
> （float）、（double）、（real）：转换成浮点型
>
> （string）：转换成字符串
>
> （bool）、（boolean）：转换成布尔类型
>
> （array）：转换成数组
>
> （object）：转换成对象



**==注意==**：除了资源类型，其他类型均可实现强制类型转换。

**==演示案例==**：![90](\images\two\img_d3\90.png)

**==小结==**：

只需要在变量或数据前加上小括号，并且指定需要转换的数据类型即可（注意除了资源类型，其他均可转换）。



#### 7.2.2 具体类型的**转换函数**

| 函数           | 用法                 | 语法                                                         |
| -------------- | -------------------- | ------------------------------------------------------------ |
| **intval()**   | 获取变量的整数值     | intval (mixed $var [, int $base = 10 ] )  base 转换进制，返回变量 var 的 int 数值。 |
| **boolval()**  | 获取变量的布尔值     | boolval ( mixed $var )    返回var变量的布尔值。              |
| **floatval()** | 获取变量的浮点值     | floatval ( mixed $var )   返回变量 var 的 float 数值。       |
| **strval()**   | 获取变量的字符串值。 | strval ( mixed $var )  返回 var 的 string 值。var 可以是任何标量类型。 |



#### 7.2.3 通用**类型转换函数**settype()

**定义和用法**

settype() — 设置变量的类型

**语法**

```php
bool settype ( mixed &$var , string $type )
```

将变量 var 的类型设置成 type。 

| 参数       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| ***var***  | 要转换的变量。                                               |
| ***type*** | **type**` 的可能值为：                                                                                                                                                                    “**boolean**” （或为“bool”，从 PHP 4.2.0 起）                                                                                             “**integer**” （或为“int”，从 PHP 4.2.0 起）                                                                                                       **“float**” （只在 PHP 4.2.0 之后可以使用，对于旧版本中使用的“double”现已停用）                       "**string**"                                                                                                                                               "**array**"                                                                                                                                                 "**object**"                                                                                                                                                         “**null**” （从 PHP 4.2.0 起） |

**技术细节**

| 返回值：   | ``将变量 var 的类型设置成 type。 |
| ---------- | -------------------------------- |
| PHP 版本： | PHP 4, PHP 5, PHP 7              |



------



### 7.3 其他类型转布尔型的问题

TIPS：我们只需弄明白什么情况下其他数据类型转换为布尔类型会是false，那么其余的情况就都是true了。



**==要点==**：当一个数据为 ==空字符串==，==空数组==，==0==（零值，包括==0值字符串==，==0.00浮点数==），==NULL值==时，都将转换为false。

**==演示案例==**：

![91](\images\two\img_d3\91.png)



------



### 7.4 类型判断相关函数

涉及的函数：

> gettype函数    获取数据的数据类型
>
> is_numeric函数     判断是否是一个数值
>
> is_int函数    判断是否是一个整型值	
>
> is_bool函数    判断是否是一个布尔型值
>
> is_float函数    判断是否是一个浮点型值
>
> is_string函数    判断是否是一个字符串型值
>
> is_array函数    判断是否是一个数组型值
>
> is_object函数    判断是否是一个对象型值
>
> is_resource函数    判断是否是一个资源型值
>
> is_null函数    判断是否是一个null类型值

**==演示案例==**：

![93](\images\two\img_d3\93.png)



## 8. 运算符

程序语言的实现基础是数学，数学中有运算符的概念，程序语言中相应的也存在运算符。

### 8.1 赋值运算符

| **赋值**     | **等同于**   | **描述**                       |
| ------------ | ------------ | ------------------------------ |
| $x **=** $y  | $x = $y      | 右侧表达式为左侧运算数设置值。 |
| $x **+=** $y | $x = $x + $y | 相加                           |
| $x **-=** $y | $x = $x - $y | 相减                           |
| $x ***=** $y | $x = $x * $y | 相乘                           |
| $x **/=** $y | $x = $x / $y | 相除                           |
| $x **%=** $y | $x = $x % $y | 相取余（模）                   |

==**演示案例**==：

![105](\images\two\img_d4\105.png)



### 8.2 算数运算符

| **运算符** | **名称** | **例子** | **结果**        |
| ---------- | -------- | -------- | --------------- |
| +          | 加法     | $x + $y  | $x 与 $y 求和   |
| -          | 减法     | $x - $y  | $x 与 $y 的差数 |
| *          | 乘法     | $x * $y  | $x 与 $y 的乘积 |
| /          | 除法     | $x / $y  | $x 与 $y 的商数 |
| %          | 模数     | $x % $y  | $x 除 $y 的余数 |

==**演示案例**==：

![106](\images\two\img_d4\106.png)



### 8.3 比较运算符

| **运算符** | **名称**           | **例子**  | **结果**                                                     |
| ---------- | ------------------ | --------- | ------------------------------------------------------------ |
| ==         | 等于               | $x==$y    | 如果 $x 等于 $y，则返回 true。                               |
| ===        | 全等（完全相同）   | $x===$y   | 如果 $x 等于 $y，且它们类型相同，则返回 true。               |
| !=         | 不等于             | $x != $y  | 如果 $x 不等于 $y，则返回 true。                             |
| <>         | 不等于             | $x <> $y  | 如果 $x 不等于 $y，则返回 true。                             |
| !==        | 不全等（完全不同） | $x!==$y   | 如果 $x 不等于 $y，或它们类型不相同，则返回 true。           |
| \>         | 大于               | $x > $y   | 如果 $x 大于 $y，则返回 true。                               |
| <          | 小于               | $x < $y   | 如果 $x 小于 $y，则返回 true。                               |
| \>=        | 大于或等于         | $x >= $y  | 如果 $x 大于或者等于 $y，则返回 true。                       |
| <=         | 小于或等于         | $x <= $y  | 如果 $x 小于或者等于 $y，则返回 true。                       |
| <=>        | 飞船运算符         | $x <=> $y | 如果左边小于右边返回-1，如果左边等于右边返回0，如果左边大于右边返回1。 |



### 8.4 逻辑运算符

| **运算符** | **名称** | **例子**               | **结果**                                             |
| ---------- | -------- | ---------------------- | ---------------------------------------------------- |
| and 或 &&  | 与       | $x and $y或 $x && $y   | 如果 $x 和 $y 都为 true，则返回 true                 |
| or 或 \|\| | 或       | $x or $y 或 $x \|\| $y | 如果 $x 和 $y 只要有一个为 true，则返回 true         |
| xor        | 异或     | $x xor $y              | 如果 $x 和 $y 有且仅有一个为 true，则返回 true       |
| !          | 非       | !$x                    | 如果 $x 为 true，则返回 false，$x为false，则返回true |

#### 8.4.1 短路运算

TIPS：使用  逻辑与  或  逻辑或  运算符时，==由于第一个条件已经能够决定整个运算的结果，而导致无需运行第二个条件的现象==，就被称为短路运算。

==**演示案例**==：

![112](\images\two\img_d4\112.png)



#### 8.4.2 连接运算符（字符串运算符）

| **运算符** | **名称** | **例子**                                    | **结果**                         |
| ---------- | -------- | ------------------------------------------- | -------------------------------- |
| **.**      | 串接     | $txt1 =   "Hello" $txt2 = $txt1 . " world!" | 现在 $txt2 包含 "Hello   world!" |
| **.=**     | 串接赋值 | $txt1 =   "Hello" $txt1 .= " world!"        | 现在 $txt1 包含 "Hello   world!" |



### 8.5 错误抑制符

符号：**@**

==**演示案例**==：![114](\images\two\img_d4\114.png)

**==小结==**：

1. 错误抑制符可以屏蔽轻量级的错误（notice和warning级别的）信息，但是却不能屏蔽致命的语法错误；
2. 错误抑制符只能屏蔽展示错误信息，但却没有实际解决错误。



### 8.6 三目运算符

语法：**条件 ? 条件为true时执行语句 : 条件为false时执行语句;**

==**演示案例**==：

![115](\images\two\img_d4\115.png)



#### 8.7 合并运算符

运算符号：**??**

合并运算符就是三目运算符和isset语句的简写。

![116](\images\two\img_d4\116.png)



### 8.8 自操作运算符

| **运算符** | **名称** | **描述**             |
| ---------- | -------- | -------------------- |
| **++**$x   | 前递增   | 先$x加一，后赋值     |
| $x**++**   | 后递增   | 先赋值，然后 $x 加一 |
| **--**$x   | 前递减   | 先$x减一，后赋值     |
| $x**--**   | 后递减   | 先赋值，然后 $x 减一 |

==**演示案例**==：

![117](\images\two\img_d4\117.png)

**==注意==**：不要在==复合运算==或==调用函数传参时==使用自操作运算符。



### 8.9 位运算符

| **运算符** | **名称** | **描述**                                                    |
| ---------- | -------- | ----------------------------------------------------------- |
| $a**&**$b  | 按位与   | 把 *$a* 和 *$b* 中都为 1 的位设为 1，其余位置设为0          |
| $a**\|**$b | 按位或   | 把 *$a* 和 *$b* 中都为 0 的位设为0，其余位置设为1           |
| $a**^**$b  | 按位异或 | 把 *$a* 和 *$b* 中一个为 1 另一个为 0 的位设为 1，其余设为0 |
| **~**$a    | 按位取反 | *$a* 中为 0 的位设为 1，为1的位设为0                        |
| $a**<<**$b | 左移     | *$a* 中的位向左移动 *$b* 次                                 |
| $a**>>**$b | 右移     | *$a* 中的位向右移动 *$b* 次                                 |

==**演示案例**==：5&4

上下同为1的位置设置为1，其余位置设置为0。

![118](\images\two\img_d4\118.png)



==**演示案例**==：5|4

![119](\images\two\img_d4\119.png)



==**演示案例**==：5<<2

![120](\images\two\img_d4\120.png)



==**演示案例**==：5>>2

![121](\images\two\img_d4\121.png)





### 8.10 运算符的优先级

在数学中，我们进行运算时，是先乘除后加减，这里说的就是存在运算符的优先级问题。

在PHP中，所有的运算符，也具有优先级。手册中有详细的关于PHP运算符优先级的说明，

| 结合方向 | 运算符                                                       | 附加信息                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无       | **clone**   **new**                                          | [clone](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.oop5.cloning.html) 和 [new](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.oop5.basic.html#language.oop5.basic.new) |
| 左       | **[ ]**                                                      | [array()](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/function.array.html) |
| 右       | ******                                                       | [算术运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.arithmetic.html) |
| 右       | **++**          **--**          **~**          **(int)**          **(float)**          **(string)**          **(array)**          **(object)**          **(bool)**          **@** | [类型 ](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.types.html)和 [递增／递减](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.increment.html) |
| 无       | **instanceof**                                               | [类型](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.types.html) |
| 右       | **!**                                                        | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |
| 左       | *****         **/**          **%**                           | [算术运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.arithmetic.html) |
| 左       | **+**          **-**          **.***                         | [算术运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.arithmetic.html) 和 [字符串运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.string.html) |
| 左       | **<<**          **>>**                                       | [位运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.bitwise.html) |
| 无       | **<**          **<=**          **>**          **>=**         | [比较运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.comparison.html) |
| 无       | **==**          **!=**          **===**          **!==**          **<>**          **<=>** | [比较运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.comparison.html) |
| 左       | **&**                                                        | [位运算符 ](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.bitwise.html)和 [引用](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.references.html) |
| 左       | **^**                                                        | [位运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.bitwise.html) |
| 左       | **\|**                                                       | [位运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.bitwise.html) |
| 左       | **&&**                                                       | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |
| 左       | **\|\|**                                                     | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |
| 左       | **??**                                                       | [比较运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.comparison.html) |
| 左       | **? :**                                                      | [ternary](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.comparison.html#language.operators.comparison.ternary) |
| 右       | **=**          **+=**          **-=**          ***=**          **\=**          **/=**          **.=**         **%=**          **&=**          **\|=**          **^=**          **<<=**          **>>=** | [赋值运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.assignment.html) |
| 左       | **and**                                                      | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |
| 左       | **xor**                                                      | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |
| 左       | **or**                                                       | [逻辑运算符](mk:@MSITStore:D:\PHP\基础班\day1\教学软件\手册\php7.1_enhanced_zh.chm::/res/language.operators.logical.html) |

TIPS：我们在构建程序的过程中，经常会直接使用**小括号**来**强制改变运算符的优先级**。



### 8.11 位运算中的原码、反码和补码

TIPS：在计算机中，一切的数据都是二进制数据；所以，在计算机中，进行运算或者运行或者保存的二进制数据都是==以补码形式存在的==。

**原码**：原始的二进制码值

**反码**：原码取反

**补码**：反码加1（所有的二进制数据在计算机的底层都是以补码来进行计算的）

**==特别注意==**：正数的补码就等于原码。

**==演示案例==**：手动推算实现-5+2

![123](\images\two\img_d4\123.png)



## 9. 流程控制

TIPS：在程序语言中存在三大流程：1）顺序；2）分支；3）循环； 



### 9.1 顺序结构

TIPS：顺序结构其实就是==从上往下顺序执行==，这是PHP程序的基本流程结构，所有的PHP程序都是以这种结构去执行的。



### 9.2 分支结构

分支结构包括：1）if…elseif…else;  2）switch；

#### 9.2.1 if…elseif…else

#### 9.2.2 switch

语法：

```php
switch($variable){
    case 值1:
        进程结构体1;
    case 值2:
        进程结构体2；
    case 值n:
        进程结构体n；
    default:
        default进程结构体；
}
```



### 9.3 循环结构

循环结构包括：1）while循环；2）for循环； 3）do...while循环

#### 9.3.1 while循环

语法：

```php
while(循环条件){
    循环结构体
}
```

#### 9.3.2 for循环

语法：

```php
for(表达式1; 表达式2; 表达式3){ 
    for循环结构体；
}
```

#### 9.3.3 do...while循环

语法：

```php
do{    
    循环结构体；    
}while(循环条件);
```

#### 9.3.4 循环中的break和continue

TIPS：循环中的**break**：**中止整个循环**；循环中的**continue**：**结束当前循环，跳到下一次循环继续执行**。





------



## 10. 文件包含

如果一个程序页面的代码量非常大，那么，都写在一个页面中显然是不明智的！在PHP中，我们可以通过文件包含来将代码程序从横向（物理行数）上将其有效的分割开，方便管理和维护。



### 10.1 文件包含的四种方式

1）include；2）include_once；3）require；4）require_once；



### 10.2 四种方式的特点

四种方式包括：

> **include**：引入文件，如果引入文件时**存在错误**，**程序不会中断**，而**会继续执行**，并报一个**警告错误**；
>
> **include_once**：与include相同，但是include_once会检查被引入的文件**之前是否已经引入**，如果引进引入则不会再次引入；
>
> **require**：引入文件，如果引入文件时**存在错误**，则**程序中断执行**，并显示**致命错误**；
>
> **require_once**：与require相同，但是require_once会检查被引入的文件**之前是否已经引入**，如果引进引入则不会再次引入；



**注意**：上面四句话中所指的**引入文件时存在错误**，特指**引入了一个不存在的文件**时，而并不是指引入的那个文件中存在错误！



**==演示案例==**：

1. include和require的区别（与include_once和require_once的区别相同）

------

1) include引入一个不存在的文件:

```php
<?php 
	//1.include引入一个不存在的文件
	include './code2.php';
	echo $name;
	echo "123";echo "<hr>";
```

效果：

![1](\images\two\img_d5\1.jpg)



2)require引入一个不存在的文件:

```php
<?php	
	//3.require
	require './code2.php';
	echo "123";echo "<hr>";
```

效果：

![2](\images\two\img_d5\2.jpg)



------

2. include和include_once的区别（与require和require_once的区别相同）

1) include引入一个不存在的文件:如上

2）include_once引入一个不存在的文件:

```php
<?php		
	//2.include_once  	
	include './code1.php';
	include_once './code1.php';
	var_dump(URL);
```

效果：

![3](\images\two\img_d5\3.jpg)



**==小结==**：

1）include系列和require系列的区别是，include系列引入一个不存在的文件时，将会只报警告级别的错误，不会阻止程序继续往下执行；require系列如果引入了一个不存在的文件时，将会报致命的错误，阻止程序继续往下执行；

2）带once和不带once的区别，带once的会检查之前文件是否已经引入过，如果引入过，则本次不会重复引入；不带once的将不会检查文件之前是否已经引入过；



------



### 10.3 加载路径的问题

TIPS：程序中加载路径分为两种，1）相对路径；2）绝对路径；



#### 10.3.1 相对路径

当前目录："**./**"表示当前目录。

上级目录："**../**"表示当前目录的上一级目录。



TIPS：使用相对路径时需要弄明白一个问题：相对路径到底是相对于哪一个目录！ 

**==演示案例==**：

1. 使用相对路径引入程序文件。

![140](\images\two\img_d5\140.png)



2. 测试相对路径的稳定性问题。

1) 在code目录下创建一个名为t的目录，并且在t目录下创建两个程序文件，内容分别如下：

t.php ![141](\images\two\img_d5\141.png)

t1.php![142](\images\two\img_d5\142.png)



2) 在code目录下创建了一个名为code3.php的程序，内容如下：

![143](\images\two\img_d5\143.png)



3) 访问code3.php，效果如下：

![144](\images\two\img_d5\144.png)



从效果中我们了解到：

相对路径，相对的是**当前被执行的程序文件所在的目录**的，所以在code3.php中引入t1.php文件是能够引入成功的，因为程序会从当前被执行的程序文件code3.php所在的目录code目录中去找t目录下的t1.php文件，所以能够找到，故$t1变量可以正常输出；但是在t1.php中引入的那个t.php文件，也会从当前被执行的程序文件code3.php所在的目录code中去找t.php，故找不到这个文件，所以$t不可能输出成功。



**==小结==**：

1）"./"表示当前目录；"../"表示当前目录的上一级目录；

2）相对路径相对的都是：==当前被执行的程序文件所在的目录而言的==，与写在哪个文件中没有关系；



##### 拓展：HTML中使用相对路径问题

TIPS：在html中使用相对路径，最上级只能到网站的根目录。



------



#### 绝对路径

TIPS：绝对路径就是从盘符开始指定到目录或文件的全路径地址。 

**==演示案例==**：

1. 测试使用绝对路径引入程序文件。

![146](\images\two\img_d5\146.png)



2. 测试\_\_FILE\_\_魔术常量。

![147](\images\two\img_d5\147.png)



**==小结==**：

1）绝对路径指的就是从盘符开始一直到文件名为止的全路径地址。



### 10.4 文件的嵌套包含

TIPS：在程序中可以使用引入文件的方式实现文件的嵌套包含。

**==演示案例==**：

1. 在PHP程序中将代码进行物理分割。

![148](\images\two\img_d5\148.png)



2. 在html代码中进行代码的物理分割。

   1) 在code中创建一个名为code14.php的文件，内容如下：

![149](\images\two\img_d5\149.png)

2) 再在code目录下分别创建名为code12.php和code13.php的文件，内容分别如下：

code12.php

![150](\images\two\img_d5\150.png)

code13.php

![151](\images\two\img_d5\151.png)

3) 分别测试访问code12.php和code13.php，

访问code12.php，效果为：

![152](\images\two\img_d5\152.png)

访问code13.php，效果为：

![153](\images\two\img_d5\153.png)



**==小结==**：

我们可以通过使用文件引入的方式，既能够在php程序中做代码的物理分割，又能够在html里面做代码的物理分割。



------



## 11.  数组进阶

### 11.1 数组分类

按**下标的类型**来划分：

1）**索引**数组（数组的下标为整型）；  2）**关联**数组（数组的下标为字符串）；

按**维度**来划分：

1）一维数组；                                        2）多维数组；



### 11.2 多维数组

#### 11.2.1 二维数组

概念：每一个元素的值都是一个一维数组。 

**==演示案例==**：

定义二维数组，并且访问二维数组中的元素值。

![154](\images\two\img_d5\154.png)



### 11.3 数组的遍历

概念：PHP中，提供了一种方式，能够让我们**逐个的**去**获得**数组中的**每一个元素**，这种方式就是数组的遍历。

遍历的方法：使用foreach结构进行遍历。

foreach语法结构：

```php
foreach(目标数组 as [保存下标的变量=>]保存值的变量){
	遍历循环结构体
}
```

**==演示案例==**：遍历数组array('name'=>'司马光', 'age'=>12, 'accident'=>'司马光砸缸') 

![4](\images\two\img_d5\4.jpg)



#### 11.3.1 数组遍历的基本原理

TIPS：

> 1） 数组其实是程序在内存中开辟的一段**连续的**内存空间；
>
> 2） 当遍历数组的时候，每次之所以能够获得一个元素，是因为存在一个类似于箭头
>
> ​       这样的**元素指针**，指向的那个位置就是我们需要在遍历中获得的那个数组元素。



==原理图==：

![156](\images\two\img_d5\156.png)



#### 11.3.2 foreach遍历的线性流程

流程图：

![135](\images\two\img_d5\135.png)



**==细节1==**：赋值给$key这一步操作可以省略。

![5](\images\two\img_d5\5.jpg)

**==细节2==**：$key和$value变量可以命名为任意符合变量命名规则的名字。 



**==细节3==**：在遍历的过程中所操作到的数组是原数组的拷贝，而不是原数组。 

![6](\images\two\img_d5\6.jpg)



**==小结==**：

我们在程序中可以使用foreach结构来达到遍历数组的效果。需要注意几个细节：

1）foreach结构中指定的赋值给$key的部分可以省略不写；

2）$key和$value可以被命名为任何符合变量命名规则要求的名字；

3）foreach遍历的过程中实际上遍历的是原数组的一份拷贝；



#### 11.3.3 数组（遍历）的值传递和引用传递

TIPS：数组在遍历的过程中也能够实现值传递和引用传递。

**1) 值传递**

![160](\images\two\img_d5\160.png)



**2）引用传递**

![161](\images\two\img_d5\161.png)



**==小结==**：

在foreach遍历数组时，$value前面加上&就能够实现数组遍历的引用传递；不做任何处理就是数组遍历的值传递；



### 11.4 数组相关函数

涉及的函数：

> 1）排序函数
>
> ​	 ==sort==(), asort(), rsort(), arsort(), ksort(), krsort(), ==shuffle==()
>
> 2）元素指针函数
>
> ​	 ==current==(), ==key==(), ==next==(), ==end==(), prev(), ==reset==(), ==each==()
>
> 3）其他函数
>
> ​	 ==count==(), array_push(), array_pop(), array_reverse(), ==in_array==(), 
>
> ​	 ==array_keys==(), ==array_values==(), ==list==()，==array_merge==(), ==range==()





------



#### 11.4.1 排序函数

| 函数     | 描述                                            |
| -------- | ----------------------------------------------- |
| sort()   | 对数值数组进行升序排序。 重新规划元素的下标     |
| asort()  | 对数值数组进行升序排序。 持元素的原下标不变     |
| rsort()  | 对数值数组进行降序排序。 重新规划元素的下标     |
| arsort() | 对数值数组进行降序排序。 持元素的原下标不变     |
| ksort()  | 对关联数组按照键名升序排序。                    |
| krsort() | 对关联数组按照键名降序排序。                    |
| shuffle  | 把数组中的元素按随机重新排列。 重新规划元素下标 |



#### 11.4.2 元素指针函数

| 函数      | 描述                                     |
| --------- | ---------------------------------------- |
| current() | 获取当前元素指针所在位置上的元素的值     |
| key()     | 获取当前元素指针所在位置上的元素键(下标) |
| next()    | 将数组中的内部指针向右移动一位。         |
| end()     | 将数组的内部指针指向最后一个元素。       |
| prev()    | 将数组的内部指针向左倒回一位。           |
| reset()   | 将数组的内部指针指向第一个元素。         |
| each()    | 返回数组中当前的元素组成新的数组。       |



#### 11.4.3 操作元素

| 函数                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| array_push()                 | 添加新元素的(只能在末尾添加值) 。返回新数组的元素个数 。(增) |
| array_unshift ()             | 在数组开头插入一个或多个元素。  返回新数组中元素的个数。 (增) |
| array_pop()                  | 删除指定数组中最后一个元素。数组的最后一个值 (删)            |
| array_shift()                | 删除数组中的第一个元素 。 返回被删除元素的值(删)             |
| array_reverse()              | 将元素的顺序颠倒。索引下标重新规划下标，字符串下标不变(改)   |
| array_merge()                | 将两个数组合并。索引下标重新规划下标，字符串下标不变(改)     |
| array_flip( $arr )           | 数组中的值与键名互换（如果有重复前面的会被后面的覆盖）(改)   |
| in_array("value",$arr)       | 函数搜索数组中是否存在指定的值。返回布尔。(查)               |
| array_search("value",$arr)   | 在数组中搜索给定的值，如果成功则返回相应的键名。(查)         |
| array_key_exists("key",$arr) | 检查指定的键名是否存在于数组中。返回布尔。(查)               |
| isset($arr[key])             | 检索给定的键名是否存在数组中。返回布尔。(查)                 |



#### 11.4.4 提取信息

| 函数           | 描述                                             |
| -------------- | ------------------------------------------------ |
| count()        | 获取数组元素的总个数                             |
| array_keys()   | 提取数组的所有下标形成新的数组。重新规划下标     |
| array_values() | 提取数组的所有元素的值形成新的数组。重新规划下标 |



#### 11.4.5 数组和变量转换

| 函数                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| extract($arr)           | 把元素转换成变量导入到当前的符号表 ，键名当变量名，值作为变量值 |
| compact(var1,var2,var3) | 创建一个包含变量名和它们的值的数组。                         |



#### 11.4.6 分段和填充

| 函数           | 描述                                                 |
| -------------- | ---------------------------------------------------- |
| array_slice( ) | 将数组中的一段取出，返回数组中的选定部分。           |
| array_splice() | 移除选定的元素并用新元素取代。返回被移除元素的数组。 |
| array_chunk()  | 把一个数组分割为新的数组块。                         |
| array_pad()    | 将指定数量的带有指定值的元素插入到数组中。           |



#### 11.4.7 数组计算

| 函数                                        | 描述                                             |
| ------------------------------------------- | ------------------------------------------------ |
| array_sum($arr)                             | 对数组内部的所有元素做求和运算 。非数值为0       |
| array_product ()                            | 求数组中所有值的积                               |
| array_diff(*array1,array2...*);             | 比较数组，返回两个数组的差集 。（只比较键值）    |
| array_diff_assoc(*array1,array2* ...)       | 比较数组，返回两个数组的差集（比较键名和键值）   |
| array_intersect(*array1,array2* ...）       | 比较数组，返回两个数组的交集（只比较键值）。     |
| array_intersect_assoc(*array1,array2* ...） | 比较数组，返回两个数组的交集（比较键名和键值）。 |



#### 11.4.8 其他

| 函数                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| list()                     | 把数组中的**值**赋给一些变量。 只对数组里的索引数组有效。从0起 |
| range()                    | 按照指定字符范围构件数组                                     |
| array_unique(*array*)      | 移除数组中重复的值。 返回过滤后的数组。                      |
| array_rand(array,number* ) | 从数组中随机选出一个或多个元素，返回键名。                   |
| shuffle(*array*)           | 把数组中的元素按随机顺序重新排列。                           |


