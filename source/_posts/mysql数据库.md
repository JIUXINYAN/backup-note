---
title: mysql数据库
date: 2019-01-09 14:06:27
categories: 
          - php
tags:
    - php
notshow: true
---
# MYSQL数据库
<!-- more -->

## 1. MYSQL基本介绍

### 1.1 为什么使用MYSQL数据库

我们的生活当中，很多地方都离不开数据库，银行，大学，图书馆等就是几个严重依赖数据库系统的地方。在互联网中，使用的搜索引擎，访问的绝大部分网站也都离不开数据库。而MYSQL数据库是众多数据库中比较出类拔萃的一种。总体而言，MYSQL数据库有如下一些主要优点：

> 1)    执行速度快，MYSQL是市面上执行SQL速度最快的SQL软件之一；
>
> 2)    并发处理能力好，理论上可以同时处理几乎不限数量的用户；
>
> 3)    存储能力强，可以处理多达50000000以上的记录；
>
> 4)    对商业和个人用户均开源并且免费；



### 1.2 什么是MYSQL数据库

LOGO：

![1](\images\two\img_d7\1.png)

MySQL是一种开放源代码的**关系型**数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言--**结构化查询语言**（SQL）进行数据库管理。



SQL：**Structure Query Language**  意思是 **结构化查询语言**



由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。 



MySQL这个名字，起源不是很明确。一个比较有影响的说法是，基本指南和大量的库和工具带有前缀“my”已经有10年以上，而且不管怎样，MySQL AB创始人之一的Monty Widenius的女儿也叫My。这两个到底是哪一个给出了MySQL这个名字至今依然是个迷，包括开发者在内也不知道。



MySQL的海豚标志的名字叫“sakila”，它是由MySQL AB的创始人从用户在“海豚命名”的竞赛中建议的大量的名字表中选出的。获胜的名字是由来自非洲斯威士兰的开源软件开发者Ambrose Twebaze提供。根据Ambrose所说，Sakila来自一种叫SiSwati的斯威士兰方言，也是在Ambrose的家乡乌干达附近的坦桑尼亚的Arusha的一个小镇的名字。



#### 1.2.1 数据库的分类

数据库通常分为**层次式数据库**、**网络式数据库**和**关系式数据库**三种。

而不同的数据库是按不同的数据结构来联系和组织的。在当今的互联网中，最常见的数据库模型主要是两种，即**关系型数据库**和**非关系型数据库**。



MYSQL数据库是**关系型数据库**模型的典型代表。



#### 1.2.2 MYSQL的发展历程

> MySQL的历史最早可以追溯到**1979年**，
>
> 
>
> 那时Oracle也才小打小闹，微软的SQL Server影子都没有。Monty Widenius在其合伙的TcX小公司工作时，用BASIC设计了一个报表工具。随着时间的推移，这个小工具被用C重写并迁移到Unix上运行。当时，它只是一个很底层的面向报表的存储引擎，再配上一个报表前端。它就是大家知道的Unireg。
>
> 
>
> **1990年**，Monty因为不满访问数据的SQL接口的速度，决心自己重写一个SQL。
>
> 
>
> 该公司的客户急切要求访问其数据的SQL接口，TcX提出其中一方案是把数据都加载进一个商用数据库。但Monty对这个方案的执行速度并不满意。他尝试将mSQL的代码用做SQL层，并用自己的低层级的存储引擎集成进来，但效果也不好。于是, Monty决心自己重写一个SQL。
>
> 
>
> **1996年，MySQL 1.0发布**。
>
> 
>
> 同年10月，MySQL 3.11.1发布，只提供了Solaris下的二进制版本。一个月后，Linux二进制包也发布。 此时的MySQL还非常简陋，除了在一个表上做一些Insert，Update，Delete和Select 操作，没有其他更多的功能。 
>
> 接下来的两年里，MySQL依次移植到各个平台下。它发布时，采用的许可策略，有些与众不同：允许免费商用，但是不能将MySQL与自己的产品绑定在一起发布。如果想一起发布，就必须使用特殊许可，意味着要花银子。
>
> MySQL3.22应该是一个标志性的版本，提供了基本的SQL支持。还带有一个复杂的优化器，新版本速度很快，且非常稳定。尽管如此，它还是不支持事务、子查询、外键、存储过程和视图，只存在表级别的锁。
>
> 
>
> **1999-2000**，一个名叫MySQL AB的独立公司成立了（Monty Widenius也作为创始人之一）
>
> 
>
> 它聘请了几位开发者并与Sleepycat公司建立合作伙伴关系，提供访问Berkeley DB数据文件的SQL接口。自从Berkeley DB具备事务功能之后，它就赋于了MySQL支持事务的特质，补上了它的短板。在为集成的Berkeley DB做了一些修改之后，MySQL 3.23发布了。
>
> 
>
> **2000 年，MySQL 公布了自己的源代码，并采用GPL（GNU General Public License）许可协议，正式进入开源世界。** 
>
> 
>
> **2004年10月MySQL 4.1发布，2005年10月发布里程碑的一个版本 5.0。**
>
> 
>
> 在5.0 之后的版本里，MySQL明确地表现出迈向高性能数据库的发展步伐。5.1版本紧随其后，其中加了好多的新的改进，如表分区（table data partitioning），基于行的复制（row-based replication）,事件调度器（event schedular），和让新存储引擎和其它插件轻松集成的标准化插件API。
>
> 
>
> **2008年1月16号 Sun公司收购MySQL。**
>
> 
>
> **2009年4月20，Oracle收购Sun公司。**





### 1.3 windows中启动与停止MYSQL服务

#### 1.3.1 命令行方式

启动MYSQL服务：**net start mysql**

关闭MYSQL服务：**net stop mysql**

**==操作演示==**：

![8](\images\two\img_d7\8.png)



#### 1.3.2 系统服务方式

**==操作演示==**：

第一步，打开WINDOWS下的系统服务界面，

![9](\images\two\img_d7\9.png)

第二步，找到MYSQL服务，进行相关管理，

右键点击MYSQL服务名称，可以进行管理操作

![10](\images\two\img_d7\10.png)



### 1.4 登陆与退出MYSQL

登陆MYSQL语句语法：**mysql  –u用户名  \[-h服务器IP地址\]  [-P端口]  -p密码**

**==操作演示==**：

![11](\images\two\img_d7\11.png)

![12](\images\two\img_d7\12.png)

退出MYSQL语句语法1：**exit**

退出MYSQL语句语法2：**quit**

退出MYSQL语句语法3：**\q**

**==操作演示==**：

![13](\images\two\img_d7\13.png)







------



## 2. MYSQL基本操作

TIPS：MYSQL的基本操作分为1）对数据库的操作；2）对数据表的操作；3）对数据表中保存的数据的操作；



### 2.1 数据库操作(databases)

| 操作           | 语法                          |
| -------------- | ----------------------------- |
| 显示所有数据库 | **show** databases;           |
| 创建数据库     | **create** database 数据库名; |
| 删除数据库     | **drop** database 数据库名;   |
| 选择数据库     | **use** 数据库名;             |

#### 2.1.1 显示所有数据库

语句语法：**show databases;** 

**==操作演示==**：

![1](\images\two\img_d7\1.jpg)



#### 2.1.2 创建数据库

语句语法：==create database 数据库名;== 

**==操作演示==**：

![15](\images\two\img_d7\15.png)



#### 2.1.3 删除数据库

语句语法：==drop database 数据库名;==

**==操作演示==**：

![16](\images\two\img_d7\16.png)



另一种删除数据库的语句语法：==drop database if exists 数据库;== 

**==操作演示==**：

![17](\images\two\img_d7\17.png)



#### 2.1.4 选择数据库

选择数据库的操作，就相当于先进入到某个仓库的操作。

语句语法：==use 数据库名;==

**==操作演示==**：

![18](\images\two\img_d7\18.png)







------



### 2.2 数据表操作(tables)

| 操作                      | 语法                                                  |
| ------------------------- | ----------------------------------------------------- |
| 显示所有数据表            | **show tables**;                                      |
| 创建数据表                | **create table** 表名( 字段1名  数据类型  属性, ...); |
| 删除数据表                | **drop table** 表名;                                  |
| 显示表结构                | **desc** 表名;                                        |
| 显示建表语句              | **show create table 表名\G;**                         |
| 修改表属性 charset/engine | **alter table 表名 charset=gbk;**                     |
| 修改表名,移动表           | **rename** table 库名.旧表名 to 新库名.新表名;        |



------



#### 数据表操作

1. 显示所有数据表：show tables;

2. 创建数据表：

   ```mysql
   create table 表名(
   字段1名  字段1的数据类型  [字段1的属性],
   字段2名  字段2的数据类型  [字段2的属性],
   字段n名  字段n的数据类型  [字段n的属性],
   );
   ```

3. 删除数据表：drop table 表名;

4. 显示表结构：desc 表名;

5. 显示建表语句：show create table 表名\G

6. 设置表属性：

   ```
   create table 表名(
   字段1名  字段1的数据类型  [字段1的属性],
   字段2名  字段2的数据类型  [字段2的属性],
   字段n名  字段n的数据类型  [字段n的属性],
   )engine=表引擎 charset=字符集;
   ```

7. 查看表属性：show table status like '表名';

8. 修改表属性：alter table 表名 属性名=属性新值;

9. 修改表名（只针对当前所在的数据库修改表名）：rename table 旧表名 to  新表名；

   转移数据表到指定的数据库中：rename table 库名.旧表名 to 库名.新表名;



------



#### 2.2.1 显示所有数据表

语句语法1：**show tables;**

**==操作演示1==**：

![19](\images\two\img_d7\19.png)

如果正常情况没有选择数据库，则show tables将会报错：

![20](\images\two\img_d7\20.png)



语句语法2：==show tables in 数据库名;==

表示查看某个指定的数据库中的所有的表。

**==注意==**：1）这个操作不用预先选择某个数据库；2）这个操作也不会切换数据库； 

**==操作演示2==**：

![21](\images\two\img_d7\21.png)



#### 2.2.2 创建数据表

TIPS：其实在MYSQL中创建一个数据表，就相当于在excel表中定义了一个表的表头。

语句语法：

```mysql
create table 表名(
字段1名  字段1数据类型  [字段1属性],
字段2名  字段2数据类型  [字段2属性],
字段n名  字段n数据类型  [字段n属性]
);
```



**==需求==**：创建一个如下条件的数据表：

```mysql
学生表
stu
学生姓名,学生年龄
name,age
```

**==解答==**：

![22](\images\two\img_d7\22.png)





#### 2.2.3 删除数据表

语句语法：**drop table 表名;**

**==操作演示1==**：

![23](\images\two\img_d7\23.png)



另一种删除表的语句语法：==drop table if exists 表名;== 

**==操作演示2==**：

![24](\images\two\img_d7\24.png)



#### 2.2.4 显示表结构

语句语法：**describe 表名;**

**==操作演示==**：

![25](\images\two\img_d7\25.png)



简写语法：**desc 表名;**

**==操作演示==**：

![26](\images\two\img_d7\26.png)



#### 2.2.5 显示建表语句

语句语法：**show create table 表名;**

**==操作演示==**：

![27](\images\two\img_d7\27.png)



更加良好的格式展示 ：**show create table 表名\G**

**==操作演示==**：

![28](\images\two\img_d7\28.png)



==**细节1**==：一般情况下MYSQL中不能使用关键字作为表的字段名或表名。

![29](\images\two\img_d7\29.png)



==**细节2**==：反引号“`”包裹的字段名或表名将只会被MYSQL当成普通字符来处理。

![30](\images\two\img_d7\30.png)



#### 2.2.6 设置表属性

TIPS：建表时我们可以单独为所建的表设定属性。

**==操作演示==**：

![31](\images\two\img_d7\31.png)



==**拓展知识**==：查看表属性语句：**show table status like ‘表名’;**

**==操作演示==**：

![32](\images\two\img_d7\32.png)



#### 2.2.7 InnoDB和MyISAM引擎的区别

两种引擎之间的区别挺多的，但是，最主要的区别是：

1）  通常InnoDB引擎使用的是**行级锁**；MyISAM引擎使用的是**表级锁**。（非绝对）

2）  InnoDB引擎支持**外键**，MyISAM引擎不支持。

3）  InnoDB引擎支持**事务**，MyISAM引擎不支持。



#### 2.2.8 修改表属性

语句语法：**alter table 表名 属性名=新属性值;** 

**==操作演示==**：

![33](\images\two\img_d7\33.png)



#### 2.2.9 修改表名

语句语法：**rename table [库名.]旧表名 to [库名.]新表名;**

**==操作演示==**：

![34](\images\two\img_d7\34.png)



==细节==：rename语句的另外一个作用，可以转移一个表到指定的库中。 

**==操作演示==**：

![35](\images\two\img_d7\35.png)





------



### 2.3 数据的基本操作(values)

TIPS：对数据的基本操作就是增删改查操作。



| 操作     | 语法                                                       |
| -------- | ---------------------------------------------------------- |
| 新增数据 | insert into 表名values \n (字段1)(字段2)....;              |
| 查询数据 | select  字段列表  from  表名 字句;                         |
| 修改数据 | update  表名  set  字段1=字段1新值, 字段2=字段2新值 where; |
| 删除数据 | delete from 表名 where 条件语句;                           |



#### 2.3.1 新增数据（insert语句）

语句语法：**insert into 表名 (字段1, 字段2, … 字段n)  values  (字段1值, 字段2值, … 字段n值);**

**==操作演示==**：

![36](\images\two\img_d7\36.png)



简洁的新增语句语法： **insert into 表名 values (字段1值, 字段2值, … 字段n值);**

**==注意==**：使用这种方式新增数据，则数据表中有几个字段，那么新增的数据就必须一 一为所有的字段依次指定数据值。

**==操作演示==**：

![37](\images\two\img_d7\37.png)



#### 2.3.2 查询数据（select语句）

语句语法：**select  字段列表  from  [库名.]表名  [where 查询条件];**

**==操作演示==**：

![38](\images\two\img_d7\38.png)



**==细节1==**：如果不给where条件语句，则相当于指定条件为where 1，表示查询表中的所有数据，where 1条件的意思是恒为真。

![39](\images\two\img_d7\39.png)



**==细节2==**：如果字段列表被指定为“*”，则表示需要查询所有字段的数据。

![40](\images\two\img_d7\40.png)



#### 2.3.3 更新数据（update语句）

语句语法：**update**  表名  **set**  字段1=字段1新值, 字段2=字段2新值, …. 字段n=字段n新值  **where** 条件语句; 

**==操作演示==**：

![41](\images\two\img_d7\41.png)



![42](\images\two\img_d7\42.png)



**==注意==**：请务必给更新语句指定精准的条件，如果不指定条件，那么，将会把数据表中所有行的数据都改掉。

![43](\images\two\img_d7\43.png)



#### 2.3.4 删除数据（delete语句）

语句语法：**delete from** 表名 **where** 条件语句;

**==操作演示==**：

![44](\images\two\img_d7\44.png)





------



## 3.MYSQL基础设置

### 3.1 字符集设置

#### 3.1.1 查看MYSQL中的字符集

查看MYSQL支持的所有字符集：**show charset;**

**==操作演示==**：

![46](\images\two\img_d8\46.jpg)



#### 3.1.2 字符集的概念

TIPS：字符集顾名思义就是**字符的集合**。 

字符集包括：1）字符的集合 2）字符的编码



> 世界上有非常多种类的文字，而不同的文字又有不同的字符所组成，比如英文有26个英文字母（字符），英文单词就是由这26个英文字母（字符）所组成。人们为了能够在电脑中展示出英文文字，就固定用一些值来表示这些英文字母（字符），打个比方，就好比我用0000 0001表示a，0000 0002表示b，将这些英文字母编排成一个字符的集合，取名为ASSIC码字符集。
>
>  
>
> 但是英文字母（字符）又分大小写，并且英文中除了单词还有一些符号，比如英文的逗号，冒号，分号等，于是又将这些字符全部编排进ASSIC码字符集，我们现在所使用的ASSIC码其实就是这些字符的集合。
>
>  
>
> 而最终，英文单词就是由这些字符组合而成！



#### 3.1.3 常用的字符集介绍

ASCII码  ==》 ASCII码扩展表  ==》 latin1 (包括ASCII码原表和ASCII码扩展表)

GB2312（不到8000）占2个字节  ==》gbk  （2个字节） ==》GB18030

unicode编码（占4个字节）==》 UTF-32 (占4个字节) ==》UTF-16(占2个字节) ==》UTF-8 (变长字节)



#### 3.1.4 MYSQL中的字符集设置

在MYSQL中，我们重点需要掌握三个部分的字符集设置（这三个字符集属性可以单独进行设置）

查看语句：**show variables like 'character_set_%';**

**==目标展示==**：

![47](\images\two\img_d8\47.jpg)



**==操作案例1==**：character_set_client测试

![48](\images\two\img_d8\48.jpg)

为什么上面的操作中文就报错了呢?

当前MYSQL服务器中character_set_client的值为utf8编码，说明服务器将会以UTF8编码来解析客户端发送过来的数据；

![49](\images\two\img_d8\49.jpg)

但是，我们的客户端却在以gbk编码发送数据，

![50](\images\two\img_d8\50.png)

两边的字符集编码不一致，所以就导致中文数据无法正常解析。

解决办法：在MYSQL服务器端将character_set_client的值设置为和客户端一致的编码gbk，

设置的语句语法：**set character_set_client=gbk;**

![51](\images\two\img_d8\51.png)



**==操作案例2==**：character_set_results测试

![52](\images\two\img_d8\52.png)

为什么查询中的数据会乱码呢？

因为服务器将会以utf8编码返回数据，

![53](\images\two\img_d8\53.png)

但是客户端将会以GBK编码解析返回的数据，所以中文乱码了，因为编码不一致。

解决方法：将服务器端的character_set_results设置为gbk，和客户端保持同一即可解决乱码问题。

设置方法：**set character_set_results=gbk;**

![54](\images\two\img_d8\54.png)



**==小结1==**：

要想在执行过程中避免中文的乱码问题，我们需要让客户端和服务器的字符集编码一致。



一次性设置三个字符集：**set names 目标字符集;**

**==操作演示==**：

![55](\images\two\img_d8\55.png)



**==小结2==**：

我们以后在程序中使用set names设置什么样的字符集编码，完全取决于客户端在使用什么编码。



------



### 3.2 列（字段）类型设置

在MYSQL中也存在数据类型，分别为：1）整型类型；2）小数类型；3）时间日期型；4）字符串类型； 

### 

#### 3.2.1  整型类型

| 类型             | 大小    | 有符号（最小值/最大值）                   | 无符号（最小值/最大值） |
| ---------------- | ------- | ----------------------------------------- | ----------------------- |
| **tinyint**(m)   | 1个字节 | -128/127                                  | 0/255                   |
| **smallint**(m)  | 2个字节 | -32768/32767                              | 0/65535                 |
| **mediumint**(m) | 3个字节 | -8388608/8388607                          | 0/16777215              |
| **int**(m)       | 4个字节 | -2147483648/2147483647                    | 0/4294967295            |
| **bigint**(m)    | 8个字节 | -9223372036854775808/ 9223372036854775807 | 0/18446744073709551615  |



**==演示案例==**：

创建一个测试表，其结构如下：

```
表名：tb1
字段：a、b、c、d、e
类型：tinyint、smallint、mediumint、int、bigint
```

==测试细节1==：字段保存的整型值不能超过整型极值边界。 

![56](\images\two\img_d8\56.png)





==测试细节2==：通过关键字**unsigned**来设置整型字段为无符号属性。

![57](\images\two\img_d8\57.png)



再创建一个测试表，结构如下：

```
字段：a、b
类型：int(5)、int(7)
属性：unsigned、unsigned zerofill
```

补充技术：零填充；零填充的实现方式：增加zerofill属性来设置。

==测试细节3==：整型中的m参数详解

m参数：表示该数据的**最大显示宽度**；**并不是表示该数据所占的字节数**。

![58](\images\two\img_d8\58.png)

![59](\images\two\img_d8\59.png)

**==小结==**：

1. 使用整型数据是，一定要预估好今后数据的边界。
2. 整型中的m值表示的是显示宽度，并不是表示所占的字节数。



#### 3.2.2 小数类型

| 类型              | 名称     | 大小                    | 备注                                  |
| ----------------- | -------- | ----------------------- | ------------------------------------- |
| **float**(M, D)   | 单精度数 | 4个字节                 | 默认精度位数为6到7位左右              |
| **double**(M, D)  | 双精度数 | 8个字节                 | 默认精度位数为16到17位左右            |
| **decimal**(M, D) | 定点数   | 变长,大致每9个数4个字节 | M最大为65默认为10；D最大为30默认为0； |

tips:M为总长度，D为小数位长度

**==演示案例==**：

![60](\images\two\img_d8\60.png)



==细节测试1==：float和double类型的有效位数问题。

![61](\images\two\img_d8\61.png)



==细节测试2==：M表示**整个数的位数**；D表示**小数允许的最大位数**。

1） 如果整数位数超出了计算后 整数允许的最大位数，则无法新增数据成功；

2）如果小数位数超出了限制的位数，则MYSQL会自动四舍五入进行截取。 

1)整数位超出的情况如下图：

![62](\images\two\img_d8\62.png)

2）小数位超出的情况如下图：

![63](\images\two\img_d8\63.png)



**==小结==**：

我们如果保存的是金额类型的数据，一般不采用float和double，采用decimal定点型数据类型。



#### 3.2.3 时间日期型

| 类型          | 显示格式            | 取值                                     | 大小    |
| ------------- | ------------------- | ---------------------------------------- | ------- |
| **DATETIME**  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00到9999-12-31 23:59:59 | 8个字节 |
| **TIMESTAMP** | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:00到2038-01-19 03:14:07 | 4个字节 |
| **DATE**      | YYYY-MM-DD          | 1000-01-01到9999-12-31                   | 3个字节 |
| **TIME**      | HH:MM:SS            | -838:59:59到838:59:59                    | 3个字节 |
| **YEAR**      | YYYY                | 1901到2155                               | 1个字节 |

**==演示案例==**：

![64](\images\two\img_d8\64.png)

![65](\images\two\img_d8\65.png)



==测试细节1==：timestamp的默认值为当前时间的时间戳。 

![66](\images\two\img_d8\66.png)



==细节测试2==：timestamp类型的极值需要注意时区。

![67](\images\two\img_d8\67.png)

![68](\images\two\img_d8\68.png)



==细节测试3==：time类型的数据还可以表示一个时间范围。 

![69](\images\two\img_d8\69.png)



**==小结==**：

1. 在php结合的项目中，我们通常保存时间所采用的数据类型是int整型。

**tips:** 

timestamp的默认值为当前时间的时间戳。timestamp仍然以年月日 时分秒展示，因MYSQL做了转换，实际在底层还是以整型数据的形态来存储的





#### 3.2.4 字符串类型

| 类型                                                         | 最大长度                                                     | 备注                                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------- |
| **char**(M)定长                                              | 定长字符类型：255个字符                                      | Char(M)，M表示字符个数                          |
| **varchar**(M) 变长                                          | 变长字符类型：65535字节，但需要1-2个保存信息，同时由于记录的限制，实际最大值为65532 | 编码不同字符数不同：   Gbk<=32767   Utf8<=21845 |
| **tinyText**            **text**   **mediumText** **longText** | (2^8)    --> 256字节                                                                                     (2^16)-1  --> 65535字节，约64KB                                                                          (2^24)-1 --> 16777215字节，约16M                                                                     (2^32)-1字节 --> 4294967295字节，约4G | 定义时无需指定长度，将会自动计算                |
| **enum**                                                     | 枚举：数字65535                                              | 内部存储是整型；字段只能是某一个值              |
| **set**                                                      | 集合：最多占8个字节，即64个状态值                            |                                                 |

**==注意==**：char表示定长，无论我实际的字符有多少个，都会以char定义时指定的数值大小来保存数据；varchar表示变长，保存数据的空间大小取决于实际保存的数据。 

**==演示案例1==**：char和varchar![70](\images\two\img_d8\70.png)

![71](\images\two\img_d8\71.png)



==测试细节1==：char和varchar类型括号中的最大数值表示的是字符的个数，而不是字节数。

![72](\images\two\img_d8\72.png)

在本案例中，我们假设255是字节数，那么数据表tb8所采用的字符集是utf8，一个中文占3个字节，所以如果是255个字节的话，那么最多能存储85个中文字符，现在我们新增一条数据，包含90个中文字符，如果这90个中文字符能够新增成功，则说明255是字符数，而不是字节数，反之则说明255是字节数。

那么从最终执行的结果来看，证明255是字符数。



==测试细节2==：如果varchar指定的字节长度数超过了255个字节，MYSQL会额外使用该指定长度中的**2个字节**保存这个字符数据的总长度。 

![73](\images\two\img_d8\73.png)

![74](\images\two\img_d8\74.png)

==测试细节3==：MYSQL在构建varchar类型时，当超过255个字节时，除了要使用额外的2个字节保存实际数据的长度以外，还需要用1个字节保存null值。 

![75](\images\two\img_d8\75.png)



**==演示案例==**：text

![76](\images\two\img_d8\76.png)

**==小结==**：我们通常采用text类型保存文章之类的数据。



**==演示案例==**：enum和set

![77](\images\two\img_d8\77.png)





==测试细节4==：枚举其实就相当于html中的单选按钮，枚举类型插入数据时只能选择枚举范围内的数据。

![78](\images\two\img_d8\78.png)



==测试细节5==：向集合字段新增数据的时候，所新增的数据必须在集合的元素的范围内。（集合类似于html中的多选）

![79](\images\two\img_d8\79.png)



==测试细节6==：MYSQL中集合的值，本质上都是以状态型数值存在（也就是2^n）。

![80](\images\two\img_d8\80.png)



**==小结==**：

1. 重点掌握char、varchar、text；
2. 枚举我们在实际PHP项目中经常会使用tinyint来代替。



**tips:** 

1. 枚举其实就相当于html中的单选按钮，枚举类型插入数据时只能选择枚举范围内的数据。
2. set: 相当于多选。



------



### 3.3 列属性设置

| 属性               | 用法                                                         |
| ------------------ | ------------------------------------------------------------ |
| **null**           | 字段NULL属性的默认情况为可以使用NUL值，建表时可以指定not null设置为不使用NULL值。 |
| **default**        | 为字段设置一个默认值。                                       |
| **primary key**    | 让某个字段变成主键。一个表只能有唯一的一个主键。             |
| **auto_increment** | 设置自动增长。当前如果需要指定某个字段为自动增长属性的话，则这个字段需要是主键 |
| **unique**         | 设置唯一键。如果某个字段被设置成了唯一键，那么，这个字段的值一定不能重复。一个表可以设置多个唯一键。 |
| **comment**        | 指定列描述，列描述其实就是备注内容。                         |



#### 3.3.1 null属性

字段NULL属性的默认情况为==可以使用NULL==值，建表时可以指定==not null==设置为不使用NULL值。

 

**==操作演示==**：

![81](\images\two\img_d8\81.png)

通过not null属性就可以将字段设置为不能使用NULL值。



==细节==：如果默认值是NULL，又对该字段设置了不能使用NULL值，那么，在插入NULL数据时，则无法插入成功！ 

**==操作演示==**：

![82](\images\two\img_d8\82.png)



==**小结**==：NULL值在数据表示中是否能够允许使用，取决于当前这个字段的NULL属性是否是YES，如果是YES表示允许，如果是NO表示禁止使用，我们可以通过not null控制NULL属性为NO值。



#### 3.3.2 默认值

设置方法：通过**default**关键字进行指定。

**==操作演示==**：

![83](\images\two\img_d8\83.png)



**==小结==**：以后我们在建表的时候，最好都为每个字段设置一个默认值。



#### 3.3.3主键

设置方法：指定**primary key**属性的形式让某个字段变成主键。

**==操作演示==**：

![84](\images\two\img_d8\84.png)



==细节1==：一个表只能有唯一的一个主键。

**==操作演示==**：

![85](\images\two\img_d8\85.png)



==细节2==：从数据的角度来看，主键也是唯一的。

**==操作演示==**：

![86](\images\two\img_d8\86.png)



==细节3==：建表时设置主键的另外一种方式。

**==操作演示==**：

![87](\images\two\img_d8\87.png)



**==小结==**：

1. 我们需要使用primary key关键字设置主键；
2. 一张表只能有一个主键；
3. 从数据的角度来看，主键的数据也是唯一的；



==小知识==：从查询速度的角度来讲，将一个整型字段设置主键是常用一种方式，这样做，能够使得以后指定主键为查询条件时，让查询速度会得到提升。 



#### 3.3.4 自动增长

设置方法：通过**auto_increment**属性设置自动增长。

**==注意==**：当前如果需要指定某个字段为自动增长属性的话，则这个字段需要是**主键字段**。

**==操作演示==**：

失败的情况：

![88](\images\two\img_d8\88.png)

成功的情况：

![89](\images\two\img_d8\89.png)

==细节1==：设置为自增长的字段，在插入数据时，如果不指定数据，则MYSQL会自动从上一次最大的索引id值开始+1计算。 

**==操作演示==**：

![90](\images\two\img_d8\90.png)



==细节2==：如果之前删除了某条记录，再新增数据，自增长的主键id值依然会从该表的最大索引值+1开始计算。

**==操作演示==**：

![91](\images\two\img_d8\91.png)

上面案例的原因是，当我们使用delete语句去删除数据时，索引是没有被删除的，所以之后再新增数据，主键会从残留的最大索引开始去自增长计算。



==细节3==：当我们必须给自增长字段指定值时，我们可以指定为null，则MYSQL依然会为这个字段从索引列表的最大值+1开始计算。

**==操作演示==**：

![92](\images\two\img_d8\92.png)



==细节4==：只要自增长的主键id值不重复，指定任意的数值都可以。

**==操作演示==**：

1） 指定一个曾经被删除过的主键值；![93](\images\two\img_d8\93.png)

2）指定任意不重复的主键值；

![94](\images\two\img_d8\94.png)



**==小结==**：

1. 自增长要和主键一起搭配使用；



#### 3.3.5 唯一键

设置方法：通过**unique**属性设置唯一键。 

TIPS：如果某个字段被设置成了唯一键，那么，这个字段的值一定不能重复。

**==操作演示==**：

![95](\images\two\img_d8\95.png)

![96](\images\two\img_d8\96.png)

==细节==：从定义结构角度来讲，一个表可以设置多个唯一键。

![97](\images\two\img_d8\97.png)



**==小结==**：唯一键只负责控制数据的唯一性的。



#### 3.3.6 列描述

设置方法：通过**comment**关键字来指定列描述，列描述其实就是备注内容。

**==操作演示==**：

![98](\images\two\img_d8\98.png)



**==小结==**：列描述就相当于写注释信息，给管理员和开发者看的。



### 3.4 修改表结构

| 操作                       | 语法                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 向已有的一个表中添加字段   | **alter table** 表名 **add** 新字段名 字段类型 [字段属性列表]; |
| 删除已有表中的某个字段     | **alter table** 表名 **drop** 字段名;                        |
| 改变已有表中某个字段的名字 | **alter table** 表名 **change** 旧字段名 新字段名 新字段类型 [字段属性]; |
| 修改表字段的类型或属性     | **alter table** 表名 **modify** 字段名 字段新类型 [字段新属性列表]; |



#### 3.4.1 添加字段

语句语法：==**alter table** 表名 **add** 新字段名 字段类型 [字段属性列表];== 

**==操作演示==**：

![2](\images\two\img_d9\2.png)



#### 3.4.2 删除字段

语句语法：**alter table** 表名 **drop** 字段名;

**==操作演示==**：

![3](\images\two\img_d9\3.png)



#### 3.4.3 改变字段的名字

语句语法：==**alter table** 表名 **change** 旧字段名 新字段名 新字段类型 [字段属性];== 

**==操作演示==**：

![4](\images\two\img_d9\4.png)



==细节==：如果只想单纯改名，则必须在改名的同时维持原属性不变写一次。

![5](\images\two\img_d9\5.png)



#### 3.4.4 修改字段的类型或属性

语句语法：**alter table** 表名 **modify** 字段名 字段新类型 [字段新属性列表];

**==操作演示==**：

![6](\images\two\img_d9\6.png)





------



## 4. 表关系

MYSQL中三种典型的关系：1）一对一；2）一对多；3）多对多；

典型的一对一：学生信息表 VS 学生履历表    

典型的一对多：学生信息表 VS 班级表   

典型的多对多：班级信息表 VS 教师信息表   



## 5. 高级数据操作



### 5.1 高级新增操作

#### 5.1.1 replace语句

TIPS：replace实际上就是替换insert语句中的insert关键字的，实现的功能和insert语句一模一样。 

**==操作演示==**：

![7](\images\two\img_d9\7.png)



#### 5.1.2 一次性新增多条记录

语句语法1：**insert into** 表名 **values** (数据列表1), (数据列表2)…., (数据列表n);

语句语法2：**insert into** 表名 (字段1, 字段2, …, 字段n) **values** (数据列表1), (数据列表2)…., (数据列表n);

**==操作演示==**：

![8](\images\two\img_d9\8.png)

![9](\images\two\img_d9\9.png)



#### 5.1.3 set方式新增数据

语句语法：**insert into** 表名 **set** 字段1=字段1值, 字段2=字段2值, …, 字段n=字段n值; 

**==操作演示==**：

![10](\images\two\img_d9\10.png)





------



### 5.2 子语句

| 语法         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| **where**    | 用于条件过滤，得到真实的结果。条件语句                       |
| **group by** | 用于分组统计，常与聚合函数一起使用。在最终展示的数据中，不会出现group by后面指定字段值完全相等的情况，即使查询的数据中有相同的值，也只会显示一条。 |
| **having**   | 功能上类似于where语句，负责在结果中再次进行条件过滤。        |
| **order by** | 用来按照指定的字段进行排序的。                               |
| **limit**    | 用来限制查询出来的记录的条数。                               |



#### 5.2.1 where子句    ==★==

作用：用于条件过滤，得到真实的结果。 

**==操作演示==**：

![11](\images\two\img_d9\11.png)



#### 5.2.2 group by语句

作用：用于分组统计，常与聚合函数一起使用。

TIPS：在查询的时候，如果==group by==后面指定了字段，则会额外根据指定的字段进行分组；分组的意思就是，在最终展示的数据中，不会出现group by后面指定字段值完全相等的情况，即使查询的数据中有相同的值，也只会显示一条。 

**==操作演示==**：

![12](\images\two\img_d9\12.png)



==细节==：group by不仅能够指定一个字段分组，还可以指定多个字段进行分组。 

**==操作演示==**：

![13](\images\two\img_d9\13.png)



**==小结==**：group by 其实就是将group by指定字段重复的值去掉，只保留一条数据这样的效果；



#### 5.2.3 having语句

作用：功能上类似于where语句，负责在结果中再次进行条件过滤。 

**==操作演示==**：

![14](\images\two\img_d9\14.png)



**==小结==**：having主要用于二次条件过滤；



#### 5.2.4 order by子句   ==★==

作用：用来按照指定的字段进行**排序**的。

**==操作演示1==**：**默认情况**下，是按照指定字段**升序的顺序**排序的。

![15](\images\two\img_d9\15.png)



**==操作演示2==**：如果不加上asc默认就是以asc升序排序 。

![17](\images\two\img_d9\17.png)



**==操作演示3==**：按照降序排序：使用关键字==desc==。

![18](\images\two\img_d9\18.png)



==**小结**==：order by在项目中多用于对查询的结果进行排序的。



#### 5.2.5 limit子句    ==★==

作用：用来限制查询出来的记录的条数。

**==操作演示==**：

![19](\images\two\img_d9\19.png)



==细节==：limit另外一种结构：==limit M, D;==   M表示==偏移量==，D表示==每次查询的长度==。 

**==操作演示==**：![20](\images\two\img_d9\20.png)



**==小结==**：limit的作用在程序中经常会用来做分页功能；





------



## 6. 聚合函数

| 函数           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| **count**函数  | 统计指定字段在表中的记录总条数，不统计null值。select count(*) from stu where age>=13; |
| **max**函数    | 统计指定字段数据的最大值。   select max(score) from stu where 1; |
| **min**函数    | 统计指定字段数据的最小值。   select min(score) from stu where 1; |
| **avg**函数    | 统计指定字段所有符合条件数据的平均值。select avg(score) from stu where 1; |
| **sum**函数    | 统计指定字段所有符合条件数据的总和。    select sum(score) from stu where 1; |
| **concat**函数 | 用指定的字符连接指定多个字段的数据。    select concat(name,'-',numb) from stu where 1; |



**==演示案例==**：

创建一个如以下条件的测试表stu：

```mysql
##表结构如下
学生表
stu
主键id,学生姓名,学生学号,学生年龄,学生成绩
id,name,numb,age,score

create table stu(
id int unsigned primary key auto_increment,
name varchar(30),
numb varchar(10),
age tinyint unsigned not null default 0,
score tinyint unsigned not null default 0
);

mysql> desc stu;
+-------+---------------------+------+-----+---------+----------------+
| Field | Type                | Null | Key | Default | Extra          |
+-------+---------------------+------+-----+---------+----------------+
| id    | int(10) unsigned    | NO   | PRI | NULL    | auto_increment |
| name  | varchar(30)         | YES  |     | NULL    |                |
| numb  | varchar(10)         | YES  |     | NULL    |                |
| age   | tinyint(3) unsigned | NO   |     | 0       |                |
| score | tinyint(3) unsigned | NO   |     | 0       |                |
+-------+---------------------+------+-----+---------+----------------+
5 rows in set (0.00 sec)


##测试数据如下
insert into stu values
(null, 'zhangsan', 'n10082', 12, 96),
(null, 'lisi', 'n10082', 11, 72),
(null, 'wangwu', 'n10082', 14, 59),
(null, 'zhaoliu', 'n10082', 12, 90),
(null, 'tianqi', 'n10082', 13, 84);
```

**==需求1==**：统计查询所有学生中年龄大于等于13岁的学生总共有多少个。

==**解答1**==：

![21](\images\two\img_d9\21.png)

我们通常情况下不再count函数中单独指定某个字段，而是直接指定'*'，指定'\*'表示所有字段的意思。

![22](\images\two\img_d9\22.png)

我们可以为字段列表中的字段取别名：直接通过**as**关键字实现

![23](\images\two\img_d9\23.png)



**==需求2==**：统计查询所有学生中考试成绩的最高分、最低分和平均分。

==**解答2**==：

![24](\images\two\img_d9\24.png)



**==需求3==**：统计查询所有学生的总分数。

==**解答3**==：

![25](\images\two\img_d9\25.png)



**==需求4==**：查询所有学生数据，要求姓名和学号以  "姓名-学号"  格式连接展示。

==**解答4**==：

![26](\images\two\img_d9\26.png)





------



## 7. 运算符

TIPS：MYSQL中，

1）运算符可以直接通过==select结构==进行**数据的**运算执行操作，这里的select就相当于PHP中的echo；

2）运算符如果写在查询语句的字段列表中，则将会直接计算结果；

3）运算符如果写在了条件语句中，则计算的结果还将会转换为bool值；

| 运算符                                                       | 作用                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 算数运算符(**+**、**-**、*****、**/**、**%** )               | 数运算符常用于字段列表中。                                   |
| 比较运算符(**>**、**>=**、**<**、**<=**、**=**、**！**=或**<>**) | 比较运算符多用于条件语句中使用。                             |
| 逻辑运算符(**and**、**or**、**not**)                         | 逻辑运算符多用于条件语句中使用。                             |
| **in**运算符                                                 | 在集合中为true，不在则为falses. select * from stu1 where score in(90,80,70); |
| **is**运算符                                                 | 和null搭配 (is null和is not null) ; 和true搭配 (is true和is not true) ; |
| **like**运算符（模糊匹配）                                   | like运算符经常与“**%**”一起使用，“**%**”表示任意个数的任意字符。                   select * from stu1 where content like '%日本%'; |



### 7.1 算数运算符（+、-、*、/、% ）

TIPS：算数运算符常用于==字段列表中==使用。

**==演示案例==**：

**==需求1==**：直接计算100%3, 10*20, 40-100的值。

**==解答1==**：

![27](\images\two\img_d9\27.png)



创建一个如以下条件的测试表stu1：

```mysql
##表结构如下
学生表
stu1
主键id,学生姓名,期中考成绩,期末考成绩
id,name,qz_score,qm_score

create table stu1(
id int unsigned primary key auto_increment,
name varchar(30),
qz_score tinyint unsigned,
qm_score tinyint unsigned
);

mysql> desc stu1;
+----------+---------------------+------+-----+---------+----------------+
| Field    | Type                | Null | Key | Default | Extra          |
+----------+---------------------+------+-----+---------+----------------+
| id       | int(10) unsigned    | NO   | PRI | NULL    | auto_increment |
| name     | varchar(30)         | YES  |     | NULL    |                |
| qz_score | tinyint(3) unsigned | YES  |     | NULL    |                |
| qm_score | tinyint(3) unsigned | YES  |     | NULL    |                |
+----------+---------------------+------+-----+---------+----------------+

##测试数据如下
insert into stu1 values
(null, 'zhangsan',  46, 96),
(null, 'lisi', 81, 72),
(null, 'wangwu', 62, 59),
(null, 'zhaoliu', 86, 90),
(null, 'tianqi', 80, 84);
```

**==需求2==**：计算各学员期末考与期中考的分数差。

**==解答2==**：

![28](\images\two\img_d9\28.png)



### 7.2 比较运算符（\>、>=、<、<=、=、！=或<>）

TIPS：比较运算符多用于==条件语句中==使用。

**==演示案例==**：

1）测试在条件语句中使用；

![29](\images\two\img_d9\29.png)



2）测试在字段列表中使用；

![30](\images\two\img_d9\30.png)



### 7.3 逻辑运算符（and、or、not）

TIPS：1)and表示左右两边都为真整个运算才为真；2）or表示左右两边只要有一个为真整个运算才为真；3）not表示取反，原来为真加上not就为假，原来为假加上not就为真；



**==演示案例==**：

**==需求1==**：查询stu1表中，期中考试大于80并且期末考试也大于80分的学员的全部信息；

**==解答1==**：

![31](\images\two\img_d9\31.png)



**==需求2==**：查询stu1表中，期中考试大于80==或者==期末考试也大于80分的学员信息；

**==解答2==**：

![32](\images\two\img_d9\32.png)



### 7.4 in运算符    ==★==

TIPS：in表示在==集合==中才为true，不在集合中则为false；



**==演示案例==**：

**==需求1==**：查询stu1表中，期中考试成绩为81, 82, 83, 84, 91, 92, 93分的学员都有哪些；

**==解答1==**：

使用以前的技术手段来解决：

![33](\images\two\img_d9\33.png)

使用in运算符来解决：

![34](\images\two\img_d9\34.png)



### 7.5 is运算符

TIPS：is运算符有两种搭配：

1）和null搭配（is null和is not null）；

2）和true搭配（is true和is not true）；

is null表示字段为空的值则返回true; is not null表示字段不为空则返回true。

**==演示案例==**：

往db1.stu7表中新增一条数据：

```mysql
insert into stu7 (age) values (8);
```

**==需求==**：

​	1）查询name为null的所有成员的信息；

​	2）查询name不为null的所有成员的信息；

​	3）查询age值转换为布尔值为true的所有成员的信息；

**==解答==**：

1）

![35](\images\two\img_d9\35.png)



2）

![36](\images\two\img_d9\36.png)



3）

![37](\images\two\img_d9\37.png)



### 7.6 like运算符（模糊匹配）

TIPS：like是用于模糊匹配搜索的。like运算符经常与“==%==”一起使用，“%”表示==任意个数==的==任意字符==。 



**==演示案例==**：

创建一个如以下条件的测试表：

```mysql
##表结构如下
新闻表
news
主键id,标题,内容
id,title,content

create table news(
id int unsigned primary key auto_increment,
title varchar(30),
content text
);

mysql> desc news;
+---------+------------------+------+-----+---------+----------------+
| Field   | Type             | Null | Key | Default | Extra          |
+---------+------------------+------+-----+---------+----------------+
| id      | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| title   | varchar(30)      | YES  |     | NULL    |                |
| content | text             | YES  |     | NULL    |                |
+---------+------------------+------+-----+---------+----------------+

##添加测试数据在day9.sql文件中
```

**==需求==**：查询新闻内容包含"日本"关键字新闻的新闻id和新闻标题。

**==解答==**：

![38](\images\two\img_d9\38.png)



**==小结==**：like叫模糊匹配，和"%"一起结合使用的多，多用于轻量级的搜索功能；



------



## 8. 高级查询

TIPS：高级查询部分包括：1）联合查询；2）子查询；3）连接查询；



### 8.1 联合查询

TIPS：联合查询主要包括：1）union；2）union all



#### 8.1.1 union联合查询

TIPS：union联合查询其实就是通过**union**关键字将多条查询SQL语句连接起来。

**==演示案例==**：

创建一个以下条件的数据表teacher：

```mysql 
##数据表结构如下
表名：teacher
字段：id,t_name,numb,days,class_name
类型：int,varchar(30),varchar(50),tinyint,varchar(30)

create table teacher(
id int unsigned primary key auto_increment,
t_name varchar(30),
numb varchar(50),
days tinyint unsigned,
class_name varchar(30)
);

##测试数据如下
insert into teacher values
(null, '孔子', 'N10086', 21, 'php29'),
(null, '孟子', 'N10087', 24, 'php28'),
(null, '庄子', 'N10017', 17, 'php29'),
(null, '荀子', 'N10019', 18, 'php28'),
(null, '墨子', 'N10010', 30, 'php29');
```

**==需求1==**：查询带课天数最多的教师的记录。

**==解答1==**：

![39](\images\two\img_d9\39.png)



**==需求2==**：查询带课天数最少的教师的记录。

**==解答2==**：

![40](\images\two\img_d9\40.png)



**==需求3==**：同时查询带课天数最多的教师和带课天数最少的教师的记录。

**==解答3==**：

![41](\images\two\img_d9\41.png)



**==小结==**：union经常用于将相反的两个业务逻辑的查询语句进行连接；

**==细节==**：使用union联合查询时，每个查询语句中所查的字段列表必须保持一致。

![42](\images\two\img_d9\42.png)



**==小结==**：

1. union联合查询其实就是使用关键字union进行操作；
2. 将相反的两个业务逻辑的查询语句进行联合一次查询；
3. 查询的目标字段必须保持一致，结果才是正确；



#### 8.1.2 union all

TIPS：union all和union只有一个区别，就是在保留重复数据上有所区别。

**==需求==**：查询带课天数最多的前三个教师和带课天数最少的前三个教师的记录。

**==解答==**：

1）使用union实现

![60](\images\two\img_d9\60.png)



2）使用union all实现

![61](\images\two\img_d9\61.png)





------



### 8.2 子查询

按照查询结果来进行划分：

1）标量子查询；2）列子查询；3）行子查询；4）表子查询；



#### 8.2.1 标量子查询

TIPS：标量子查询中的标量指的是 **一个单个的值**。

概念：标量子查询就是 **本条查询语句的查询条件** 是 **另一个查询语句查询出来的单个值**。

**==演示案例==**：

创建以下条件的表：

```mysql
##数据表如下
表1：teacher1
字段：id,name,numb
类型：int,varchar(30),varchar(50)

create table teacher1(
id int unsigned primary key auto_increment,
name varchar(30),
numb varchar(50)
);

表2：teacher_class
字段：id,teacher_id,days,class_name
类型：int,int,tinyint,varchar(30)

create table teacher_class(
id int unsigned primary key auto_increment,
teacher_id int unsigned,
days tinyint unsigned,
class_name varchar(30)
);

##测试数据如下
insert into teacher1 values
(null, '孔子', 'N10086'),
(null, '孟子', 'N10087'),
(null, '庄子', 'N10017'),
(null, '荀子', 'N10019'),
(null, '墨子', 'N10010');

insert into teacher_class values
(null, 1, 21, 'php30'),
(null, 3, 24, 'php31'),
(null, 2, 17, 'php30'),
(null, 2, 17, 'php31'),
(null, 5, 30, 'php30');
```

**==已知==**：教师的姓名为 孔子。

**==求==**：这个老师所有的带班信息。

**==解答==**：

使用标量子查询做简化：

![45](\images\two\img_d9\45.png)



#### 8.2.2 列子查询

概念：本条查询语句的查询条件 是 另一个查询语句查询出来的一列结果。

**==演示案例==**：使用teacher1表和teacher_class表

**==已知==**：某个教师的姓名为 孔子，另一个教师的工号为N10087。

**==求==**：这两个老师相关带课信息。

**==解答==**：

使用列子查询将以上查询操作合二为一：

![48](\images\two\img_d9\48.png)



#### 8.2.3 行子查询

概念：**本条查询语句中的查询条件** 是 另一个查询语句所查出来的**一行记录**。

**==演示案例==**：使用teacher1表

创建如下测试表：

```mysql
##表结构如下
表1：stu2
字段：name,age,teacher_name,teacher_numb,class_name
翻译：学生姓名,学生年龄,班主任姓名,班主任工号,所属班级
类型：varchar(30),tinyint,varchar(30),varchar(50),varchar(30)

create table stu2(
name varchar(30),
age tinyint,
teacher_name varchar(30),
teacher_numb varchar(50),
class_name varchar(30)
);

##测试数据如下
insert into stu2 values
('韩信', 12, '荀子', 'N10019', 'php28'),
('萧何', 16, '荀子', 'N10019', 'php29'),
('张良', 13, '孔子', 'N10086', 'php28'),
('樊哙', 15, '墨子', 'N10010', 'php26'),
('钟离昧', 12, '庄子', 'N10017', 'php29'),
('司马欣', 14, '孟子', 'N10087', 'php23'),
('陈平', 13, '孔子', 'N10086', 'php29');

##设置干扰数据
insert into teacher1 values (null, '荀子', 'N10020');
```

**==已知==**：班主任的id值为4。

**==求==**：其所带班级中学生的信息。

使用行子查询的方式将上述目标合二为一：

![53](\images\two\img_d9\53.png)

从效果上我们了解到：所谓的行子查询，其实就是本条查询语句的查询条件，是另外一条查询语句查询得到的一行结果。



#### 8.2.4 表子查询

概念：本条查询语句==所查询的表== 是 另一个查询语句查询出来的一个虚==拟表结果集==。

**==演示案例==**：使用了stu2表

创建以下条件的表：

```mysql
##根据stu2表构建stu3表
create table stu3 like stu2;

##删除stu3表中的teacher_name和teacher_numb字段
alter table stu3 drop teacher_name;
alter table stu3 drop teacher_numb;

##复制stu2表中的数据到stu3中    (蠕虫复制)
insert into stu3 (name, age, class_name) (select name, age, class_name from stu2 where 1);
```

**==要求==**：查询stu3表中php28和php29班所有学生中 年龄大于14岁学生的信息。

**==解答==**：

使用表子查询进行合二为一操作：

![56](\images\two\img_d9\56.png)



**==小结==**：

1. 使用表子查询必须为虚拟表取别名；
2. 表子查询本次查询语句的查询的表是另外一个查询语句查询得到的虚拟表；



#### 8.2.5 exists子查询

TIPS：exists子查询和查询的具体数据没有关系，只和是否查询的出数据有关。

**==演示案例==**：使用了stu2表和teacher1表。

根据以下要求调整数据表：

```mysql
##删除teacher1表中numb为N10020的干扰数据
delete from teacher1 where id=6;
```

![57](\images\two\img_d9\57.png)

**==要求==**：查询stu2表中所有 属于在职老师带领 的学生信息？ 

**==解答==**：

然后使用exists子查询实现要求的目标：

![59](\images\two\img_d9\59.png)



**==小结==**：exists子查询和实际查询得到的数据是什么值没有关系，只和满足条件的数据是否存在有关；





------



### 8.3 连接查询

连接查询分为：1）内连接；2）外连接；3）自然连接；



内连接：1）内连接；2）交叉连接；

外连接：1）左外连接；2）右外连接；3）全外连接；

自然连接：1）自然内连接；2）自然外连接；



#### 8.3.1 内连接

TIPS：内连接包括：1）内连接；2）交叉连接；

##### 1）内连接

连接方式：使用关键字**inner join**实现。

**==演示案例==**：使用了stu3表

创建以下条件的表：

```mysql
##表结构如下
表1：class
字段：name,stu_nums
翻译：班级名称,学生人数
类型：varchar(30),tinyint

mysql> create table class(
    -> name varchar(30),
    -> stu_nums tinyint
    -> );
Query OK, 0 rows affected (0.08 sec)

mysql>
mysql>
mysql> desc class;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| name     | varchar(30) | YES  |     | NULL    |       |
| stu_nums | tinyint(4)  | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+

##测试数据如下
insert into class values
('php27', 30),
('php28', 35),
('php29', 38),
('php23', 42),
('php24', 26);
```

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息？ 

**==解答==**：

我们可以按照以前学习的技术，实现分开查询，

首先查询所有的学生信息：

![2](\images\two\img_d10\2.png)

然后再查询所有学生所属班级的信息，

![3](\images\two\img_d10\3.png)



虽然我们现在能够分开来查询到所有的目标数据，但是从观察的角度来看的话，其实效果还是不太理想，所以，我们现在使用内连接的方式来改进操作：

![4](\images\two\img_d10\4.png)



**==小结==**：

1. 内连接需要通过关键字inner join来实现；
2. 如果左边的表和右边的表通过内连接条件连接不上，则MYSQL将直接不展示这条数据，所以从上面这个例子中，樊哙这条数据就没展示出来；



**==细节1==**：在两张表中，如果任意一张表的数据根据条件连不上另外一张表中的数据，则这条记录直接被忽略不展示出来。

如上面这个案例中，樊哙这条数据因为连接不上，所以没有展示出来。



**==细节2==**：内连接的简写方式可以省略inner关键字。

![5](\images\two\img_d10\5.png)



##### 2）内连接所支持的条件

TIPS：内连接支持的条件包括：on、where、using。

###### on和where

a. 在内连接中，where关键字可以代替on关键字；

![6](\images\two\img_d10\6.png)

b. 一条完整的内连接语句中==不能==同时使用两个以上的关键字on；

![7](\images\two\img_d10\7.png)![8](\images\two\img_d10\8.png)

###### using

**==演示案例==**：使用using时，左表和右表连接的条件字段必须同名。

按以下要求对相关数据表作出调整：

```mysql
##将class表中的name字段改名为class_name
alter table class change name class_name varchar(30);
```

![10](\images\two\img_d10\10.png)

![11](\images\two\img_d10\11.png)



**==要求==**：将表stu3和class使用using方式指定条件进行内连接。

**==解答==**：

![9](\images\two\img_d10\9.png)



##### 3）交叉连接

**==细节3==**：如果**内连接不指定条件**，就被称为交叉连接。所谓的交叉连接，指的是将左表的每条数据都与右表的每条数据连接一次。交叉连接又被称为"**笛卡尔积**"。

![12](\images\two\img_d10\12.png)

![13](\images\two\img_d10\13.png)



#### 8.3.2 外连接

##### 1）左外连接

TIPS：需要使用关键字 **left outer join**。

**==演示案例==**：使用了stu3表和class表

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息。

**==解答==**：

![14](\images\two\img_d10\14.png)



**==小结==**：

1. 左外连接需要使用关键字left outer join；
2. 左外连接是以左表为主，去连接右边的表，如果左表的数据连接不上右边的数据，则保留左表的数据，而右表的数据置为NULL。



**==细节==**：左外连接简写的方式可以省略outer关键字。 

![15](\images\two\img_d10\15.png)



##### 2）右外连接

TIPS：需要使用关键字 **right outer join**。

**==演示案例==**：使用了stu3表和class表

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息。

**==解答==**：

![16](\images\two\img_d10\16.png)



**==小结==**：

1. 右外连接需要使用关键字right outer join;
2. 右外连接将会以右表为主，连接左表的数据，如果右表的数据根据条件连接不上左表的数据，则保留右表的数据，将左表的数据置空。





**==细节==**：右外连接简写的方式可以省略outer关键字。

![17](\images\two\img_d10\17.png)



##### 3）全外连接

TIPS：全外连接在MYSQL不能直接通过某种语法实现，需要通过间接手段实现。

实现全外连接的思路：将左外连接与右外连接联合起来。



a. union联合（去除重复）

![18](\images\two\img_d10\18.png)



b. union all联合（全部保留）

![19](\images\two\img_d10\19.png)



##### 4）外连接支持的条件

支持的条件：on、using 

**using演示案例**：使用using的前提就是两张表中**必须有同名字段**。

![20](\images\two\img_d10\20.png)



**==细节==**：外连接==不能==使用where代替on。

![21](\images\two\img_d10\21.png)



#### 8.3.3 自然连接

自然连接包括：1）自然内连接；2）自然外连接；



##### 1）自然内连接

概念：自然内连接  **等同于**  内连接使用using条件。 

连接方法：使用关键字**natural  join**



**==演示案例==**：使用了stu3和class表

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息。

**==解答==**：

![22](\images\two\img_d10\22.png)



##### 2）自然外连接

自然外连接包括：a）自然左外连接；b）自然右外连接；



###### 自然左外连接

连接方法：使用**natural  left  join**关键字实现，等同于 左外连接使用using条件。

**==演示案例==**：使用了stu3和class表

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息。

**==解答==**：

![23](\images\two\img_d10\23.png)



###### 自然右外连接

连接方法：使用**natural  right  join**关键字实现，等同于 右外连接使用using条件。

**==演示案例==**：使用了stu1和class表

**==需求==**：查询所有学生的信息 以及 这些学生所属班级的信息。

**==解答==**：

![24](\images\two\img_d10\24.png)





------



## 9. 数据备份与还原

### 9.1 为什么使用数据的备份与还原

数据几乎是所有项目的生命线，当出现突发灾难情况的时候，比如数据丢失，遭到攻击等情况时，我们需要提前做一些准备性的工作，预防这些灾难发生后，项目无法正常运作的灾难后果。

 

在MYSQL中，我们有许多方式能够备份和还原数据。我们可以利用这些方式，提前做好准备，以防灾难发生后无法恢复数据的尴尬局面。



### 9.2 文件备份与还原

**==注意==**：文件备份的形式**只支持MyISAM引擎**。 



MyISAM引擎的数据表文件有三个，分别是： 

![25](\images\two\img_d10\25.png)



**==演示案例==**：使用文件备份与还原的方式备份数据表。

第一步，将F:\usr\mysql5.5.2\data\day10目录中的如下三个文件复制一份，

![26](\images\two\img_d10\26.png)

第二步，在MYSQL客户端中创建一个新的数据库db3,

![27](\images\two\img_d10\27.png)

创建好数据库db3后，我们发现在data目录下多了一个名为db3的文件夹，

![28](\images\two\img_d10\28.png)

第三步，将第一步复制的三个文件，粘贴到db3目录中，

![29](\images\two\img_d10\29.png)

第四步，测试使用class数据表，

![30](\images\two\img_d10\30.png)

![31](\images\two\img_d10\31.png)



### 9.3 mysqldump.exe

备份说明：我们需要通过使用mysqldump.exe可执行文件来进行数据表的备份，这种方式不限制引擎的使用。 

mysqldump.exe文件所在目录：

![32](\images\two\img_d10\32.png)

**==演示案例==**：使用mysqldump的方式备份数据表。

第一步，使用mysqldump备份db1整个数据库中的表，

![33](\images\two\img_d10\33.png)

执行备份指令后，发现day10/code目录中出现了一个名为db1.sql的新文件，

第二步，实现还原整个db1数据库中所有表，

1）在数据库中创建新的db4数据库，![34](\images\two\img_d10\34.png)

2）切换进db4数据库，

![35](\images\two\img_d10\35.png)

3）执行还原数据库的操作指令：

![36](\images\two\img_d10\36.png)

4）查看备份的结果：

![37](\images\two\img_d10\37.png)





------



## 10. 用户权限管理

### 10.1 用户管理（新增、修改密码、删除）

查看当前用户表中MYSQL用户信息：

![38](\images\two\img_d10\38.png)



#### 10.1.1 新增用户

语句语法：**create  user**  '帐号'**@**'IP地址'  **identified  by**  '原始密码';

**==演示案例==**：添加用户zhangsan；密码为1234567

![39](\images\two\img_d10\39.png)



#### 10.1.2 修改用户的密码

##### 1) 超级管理员修改用户密码

语句语法：**set  password  for**  '帐号'**@**'IP地址' **=password(**'新密码'**)**;

**==演示案例==**：

![40](\images\two\img_d10\40.png)



##### 2) 自己修改自己的密码

语句语法：**set  password=password(**‘新密码’**)**;

**==演示案例==**：

![41](\images\two\img_d10\41.png)



#### 10.1.3 删除用户

语句语法：**drop  user**  ‘帐号’**@**’IP地址’;

![42](\images\two\img_d10\42.png)



### 10.2 用户权限管理

#### 10.2.1 为用户授权操作

语句语法：**grant**  权限1[, 权限2, …, 权限n]  **on**  库名.表名  **to**  ‘帐号’@’IP地址’;

**==注意==**：库名如果是“\*”表示所有数据库;表名如果是”*”表示所有的表。

**==演示案例==**：为zhangsan帐号分配查看db1数据库中stu表数据的权限。

![43](\images\two\img_d10\43.png)



#### 10.2.2 查看用户权限

语句语法：**show  grants  for**  ‘帐号’@’IP地址’;

**==演示案例==**：

![44](\images\two\img_d10\44.png)

从第二条开始才是用户实际用的权限。



#### 10.2.3 收回权限

语句语法：**revoke** 权限1[, 权限2, …, 权限n]  **on**  库名.表名  **from**  ‘帐号’@’IP地址’;

**==演示案例==**：

![45](\images\two\img_d10\45.png)



## 11. 外键

使用外键的前提：外键所存在的表必须是**Innodb引擎**的。 



### 11.1 什么是外键

概念：如果A表中的a字段关联上了B表中的b字段，我们就说a是表A的外键。

设置外键的语句语法：**foreign  key**  (外键字段)  **references**  主表  (主表关联字段)  \[删除时执行语句\]   [更新时执行语句]



**==演示案例==**：

按照以下条件创建测试表：

```mysql
表1：goods
字段：id,name,price
翻译：主键id,商品名称,商品价格 
类型：int,varchar(30),decimal(10,2)

create table goods(
id int unsigned primary key auto_increment,
name varchar(30),                                                                    
price decimal(10, 2)
);

表2：goods_info
字段：id,goods_id,intro
翻译：主键id,商品表id值,商品描述
类型：int,int,varchar(255)

create table goods_info(
id int unsigned primary key auto_increment,
goods_id int unsigned,
intro varchar(255),
foreign key (goods_id) references goods (id)
);

##将goods_info表的goods_id设置为外键，关联上goods表的id字段
```

![47](\images\two\img_d10\47.png)

**==小结==**：当我们为goods_info表添加了外键以后，MYSQL会：

1. 将外键字段（当前是goods_info表中的goods_id字段）添加成为索引键；
2. 还会为外键取一个外键标识，相当于外键的一个别名，此处外键别名就是：goods_info_ibfk_1；



#### 11.1.2删除外键操作

外键标识：即构建外键后，MYSQL自动为该表添加的标识。

删除外键语句语法：**alter  table**  表名  **drop  foreign  key**  外键标识;

**==演示案例==**：

![48](\images\two\img_d10\48.png)

删除外键之后，发现外键标识还在，说明还没有删除干净。



==拓展知识==：

删除索引键操作

语句语法：**alter  table**  表名  **drop  index**  索引字段名;

![49](\images\two\img_d10\49.png)



==**小结**==：如果需要把外键删除，需要先删除外键标识，再删除索引键。



#### 添加外键操作

语句语法：**alter  table**  表名 **add  foreign  key**  (外键字段)  **references**  主表  (主表关联字段)  \[删除时执行语句]  [更新时执行语句]；

**==演示案例==**：

![50](\images\two\img_d10\50.png)



### 11.2外键约束

操作准备：

```mysql
##为goods表添加如下测试数据
insert into goods values
(null, '电脑', 10),
(null, '手机', 15);

##为goods_info表构建数据
insert into goods_info values
(null, 1, '电脑很好用');
```

**==前情1==**：默认情况下被关联的外键数据是无法删除的。 

**==前情1演示==**：

![51](\images\two\img_d10\51.png)



**==前情2==**：默认情况下被关联的字段值是无法被修改的。

**==前情2演示==**：

![52](\images\two\img_d10\52.png)

![53](\images\two\img_d10\53.png)



**==小结==**：被外键关联的实际数据，既不能删除，也不能被修改；



#### 11.2.1 外键约束状态

针对删除时：on delete

针对更新时：on update



#### 11.2.2 外键被允许的操作

1）cascade; （级联操作，和主表操作保持一致）

2）set null；（设置为null值）

3）restrict（==默认==）；（拒绝操作）

